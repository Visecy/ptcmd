{"config":{"lang":["en","zh"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ptcmd Documentation","text":"<p>A modern interactive command-line application building library based on <code>prompt_toolkit</code></p> <p> </p> <p><code>ptcmd</code> is a Python framework that modernizes command-line interface development by providing declarative command definitions, automatic parameter parsing, and rich interactive features. Built on <code>prompt_toolkit</code> and <code>rich</code>, it bridges the gap between Python's basic <code>cmd</code> module and full-featured CLI frameworks like <code>cmd2</code>, offering the best interactive experience with minimal complexity.</p> <p>Select language: English | \u4e2d\u6587</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Core Concepts: Introduction to the fundamental building blocks of ptcmd, including the main application structure and essential components</li> <li>Argument Handling: Comprehensive guide to defining and processing command arguments with validation and type conversion</li> <li>Command Implementation: Detailed explanation of command definition, execution flow, and advanced command patterns</li> </ul> <p>For detailed information about <code>ptcmd</code> advanced features (such as asynchronous support and rich text formatting), please refer to \"Key Features\". For in-depth introduction to core framework classes, please refer to \"User Guide\".</p>"},{"location":"feature/","title":"Features","text":"<p>This document provides a comprehensive overview of the core features and characteristics of <code>ptcmd</code>. It explains how the framework combines modern Python libraries to create a powerful CLI development experience. For implementation details of core framework classes, refer to the Core Framework. For detailed usage patterns and examples, see Examples and Usage.</p>"},{"location":"feature/#powerful-interactive-experience","title":"Powerful Interactive Experience","text":"<p><code>ptcmd</code> is built on the modern interactive library <code>prompt_toolkit</code>, offering a modern command-line experience that goes beyond basic text input/output. The framework automatically handles complex terminal interactions, providing completion and syntax highlighting.</p> <p></p>"},{"location":"feature/#declarative-argument-parsing","title":"Declarative Argument Parsing","text":"<p><code>ptcmd</code> eliminates boilerplate argument parsing code through the <code>@auto_argument</code> decorator and <code>Arg</code> type hints. The system automatically generates <code>ArgumentParser</code> instances based on function signatures, making command definitions both concise and type-safe.</p> <pre><code>from ptcmd import Cmd, Arg, auto_argument\n\nclass MathApp(Cmd):\n    @auto_argument\n    def do_add(\n        self, \n        x: float, \n        y: float,\n        *,\n        verbose: Arg[bool, \"-v\", \"--verbose\", {\"help\": \"Verbose output\"}] = False\n    ) -&gt; None:\n        \"\"\"Add two numbers\"\"\"\n        result = x + y\n        if verbose:\n            self.poutput(f\"{x} + {y} = {result}\")\n        else:\n            self.poutput(result)\n</code></pre> <p>The above example is equivalent to:</p> <pre><code>from ptcmd import Cmd, Arg, auto_argument\nfrom argparse import ArgumentParser\n\nclass MathApp(Cmd):\n    def do_add(self, argv: list[str]) -&gt; None:\n        parser = ArgumentParser(prog=\"add\", description=\"Add two numbers\")\n        parser.add_argument(\"x\", type=float)\n        parser.add_argument(\"y\", type=float)\n        parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n        ns = parser.parse_args(argv)\n        result = ns.x + ns.y\n        if ns.verbose:\n            self.poutput(f\"{ns.x} + {ns.y} = {result}\")\n        else:\n            self.poutput(result)\n</code></pre> <p>If you're using a type checker, using <code>Arg</code> may be flagged as an error. You can add <code># noqa: F821,F722,B002</code> at the end of the line to have the type checker ignore these issues. If this concerns you, you can use <code>Annotated</code> with <code>Argument</code> for a more compliant declaration, though this is more verbose and loses some automatic inference features.</p> <pre><code>from typing import Annotated\nfrom ptcmd import Cmd, Argument, auto_argument\n\nclass MathApp(Cmd):\n    @auto_argument\n    def do_add(\n        self, \n        x: float, \n        y: float,\n        *,\n        verbose: Annotated[bool, Argument(\"-v\", \"--verbose\", action=\"store_true\")] = False\n    ) -&gt; None:\n        \"\"\"Add two numbers\"\"\"\n        result = x + y\n        if verbose:\n            self.poutput(f\"{x} + {y} = {result}\")\n        else:\n            self.poutput(result)\n</code></pre>"},{"location":"feature/#rich-text-output","title":"Rich Text Output","text":"<p><code>ptcmd</code> integrates the <code>rich</code> library to provide advanced text formatting, styling, and layout capabilities. The framework encapsulates <code>rich.Console</code> functionality while maintaining compatibility with existing print-based code.</p> <p>The <code>Cmd</code> class exposes a <code>console</code> property, which is a <code>rich.Console</code> object for printing rich text. You can also use the wrapped methods <code>poutput</code>, <code>pwarning</code>, <code>perror</code>, etc., which indirectly print rich text through the <code>console</code>.</p> <pre><code>class RichApp(Cmd):\n    def do_hello(self, argv: list[str]) -&gt; None:\n        # Output using rich markup\n        self.poutput(f\"[bold blue]Hello, World![/bold blue]\")\n</code></pre> <p>The prompt supports rich text styling using either <code>rich</code> or <code>prompt_toolkit</code>.</p> <pre><code>class RichTextApp(Cmd):\n    DEFAULT_PROMPT = \"[cmd.prompt]rich[/cmd.prompt]&gt; \"\n\n    @auto_argument\n    def do_test_card(self) -&gt; None:\n        \"\"\"Show rich text\"\"\"\n        self.poutput(make_test_card())\n</code></pre> <p></p>"},{"location":"feature/#automatic-command-completion","title":"Automatic Command Completion","text":"<p><code>ptcmd</code> can automatically understand command structures, argument types, and available values based on the <code>ArgumentParser</code> instance information provided by commands. This enables automatic command completion through <code>prompt_toolkit</code>'s <code>Completer</code>.</p> <p>Completion defaults to the <code>READLINE_LIKE</code> style, which resembles terminal completion.</p> <p></p> <p>You can also use the <code>MULTI_COLUMN</code> completion style provided by <code>prompt_toolkit</code>.</p> <p></p>"},{"location":"feature/#arbitrary-multi-level-subcommands","title":"Arbitrary Multi-level Subcommands","text":"<p><code>ptcmd</code> supports adding arbitrary levels of subcommands to a command.</p> <pre><code>from ptcmd import Cmd, auto_argument\n\nclass App(Cmd):\n    @auto_argument\n    def do_server(self):\n        \"\"\"Server management\"\"\"\n\n    @do_server.add_subcommand(\"db\")\n    def db(self):\n        \"\"\"Database management\"\"\"\n\n    @db.add_subcommand(\"migrate\")\n    def migrate(self, version: str):\n        \"\"\"Execute database migration\"\"\"\n        self.poutput(f\"Migrating to version {version}...\")\n\n    @do_server.add_subcommand(\"cache\")\n    def cache(self):\n        \"\"\"Cache management\"\"\"\n\n    @cache.add_subcommand(\"clear\")\n    def clear(self, confirm: bool = False):\n        \"\"\"Clear cache\"\"\"\n        if confirm:\n            self.poutput(\"Cache cleared\")\n        else:\n            self.poutput(\"Please add --confirm to confirm the operation\")\n</code></pre>"},{"location":"feature/#native-asynchronous-support","title":"Native Asynchronous Support","text":"<p>Thanks to <code>prompt_toolkit</code>'s excellent asynchronous support, <code>ptcmd</code> natively supports asynchronous commands.</p> <pre><code>from typing import Any, Optional\nfrom aiohttp import ClientSession\nfrom ptcmd import Cmd, auto_argument\n\n\nclass RequestApp(Cmd):\n    DEFAULT_PROMPT = \"[cmd.prompt]request[/cmd.prompt]&gt; \"\n\n    @auto_argument\n    async def do_get(self, url: str, *, params: Optional[str] = None) -&gt; None:\n        \"\"\"Send a GET request to the specified URL\"\"\"\n        async with ClientSession() as session:\n            async with session.get(url, params=params) as response:\n                content = await response.text()\n                self.poutput(f\"Response from {url}:\\n{content}\")\n\n    @auto_argument\n    async def do_post(self, url: str, data: Any) -&gt; None:\n        \"\"\"Send a POST request to the specified URL with data\"\"\"\n        async with ClientSession() as session:\n            async with session.post(url, data=data) as response:\n                content = await response.text()\n                self.poutput(f\"Response from {url}:\\n{content}\")\n\n\nif __name__ == \"__main__\":\n    RequestApp().cmdloop()\n</code></pre>"},{"location":"interactive_cli/","title":"What is an Interactive Command-Line Application","text":""},{"location":"interactive_cli/#core-concepts","title":"Core Concepts","text":"<p>An Interactive Command-Line Application is a type of command-line program that allows users to interact with the program in real-time. Unlike traditional command-line applications, which read all input at once and terminate after producing output, interactive command-line applications run continuously, waiting for user commands and responding immediately to them. It's like a conversation between the user and the computer: the user continuously issues commands, and the program responds with corresponding results based on these commands.</p> <p>Take the Python interpreter's interactive mode as an example. When you enter <code>python</code> in the command line and press enter, you enter Python's interactive environment (REPL, Read-Eval-Print Loop), where the prompt is usually <code>&gt;&gt;&gt;</code>. Here, you can input Python code line by line, and the interpreter will execute your code immediately and return the result. For example, if you input <code>print(\"Hello, World!\")</code>, the interpreter will immediately output <code>Hello, World!</code>. This interaction is immediate, allowing users to decide what command to input next based on the previous command's result, just like having a real-time conversation with the program.</p> <p>Another example is the interactive command-line tools of database clients, like the MySQL command-line client. After logging into the MySQL client, users can enter various SQL statements to query and modify the database. Each time a valid SQL command is entered, the client executes it and returns the corresponding query result or operation feedback. If querying data, it displays the matching rows; if performing data insertion, it indicates whether the operation was successful. This continuous interaction process allows users to perform data operations and management step by step based on the current state of the database.</p>"},{"location":"interactive_cli/#comparison-with-standard-command-line-programs","title":"Comparison with Standard Command-Line Programs","text":"<p>The core difference between interactive command-line applications and standard command-line programs lies in state management. Interactive command-line applications maintain context state during operation without relying on external files or other methods to pass state. In contrast, each execution of a standard command-line program is an independent single operation that requires explicit state passing.</p> <p>Therefore, interactive command-line applications are more suitable for scenarios that require maintaining context state, such as various management tools that rely on network sessions or debug tools that depend on process state. Standard command-line programs are more suitable for batch processing scenarios, such as file conversion, data processing, etc.</p>"},{"location":"interactive_cli/#interaction-languages","title":"Interaction Languages","text":"<p>Unlike standard command-line applications that uniformly use terminal syntax, interactive command-line applications on the market often use different languages for interaction. For example, Python's REPL uses Python directly for interaction; gdb has its own custom interaction language for debugging programs; database clients generally use SQL for interaction.</p> <pre><code>&gt;&gt;&gt; def factorial(n: int) -&gt; int:\n...     if n &lt; 2:\n...         return 1\n...     return n * factorial(n - 1)\n...\n&gt;&gt;&gt; factorial(5)\n120\n</code></pre> <p>Some interactive command-line applications use terminal-like languages for user interaction, such as sftp. These programs resemble terminals in form but use custom commands that are not compatible with standard terminals. This approach is more intuitive for users, reducing the learning curve for syntax understanding.</p> <pre><code>sftp&gt; ?\nAvailable commands:\nbye                                Quit sftp\ncd path                            Change remote directory to 'path'\nchgrp [-h] grp path                Change group of file 'path' to 'grp'\nchmod [-h] mode path               Change permissions of file 'path' to 'mode'\nchown [-h] own path                Change owner of file 'path' to 'own'\ncopy oldpath newpath               Copy remote file\ncp oldpath newpath                 Copy remote file\ndf [-hi] [path]                    Display statistics for current directory or\n                                   filesystem containing 'path'\nexit                               Quit sftp\nget [-afpR] remote [local]         Download file\nhelp                               Display this help text\nlcd path                           Change local directory to 'path'\nlls [ls-options [path]]            Display local directory listing\nlmkdir path                        Create local directory\nln [-s] oldpath newpath            Link remote file (-s for symlink)\nlpwd                               Print local working directory\nls [-1afhlnrSt] [path]             Display remote directory listing\nlumask umask                       Set local umask to 'umask'\nmkdir path                         Create remote directory\nprogress                           Toggle display of progress meter\nput [-afpR] local [remote]         Upload file\npwd                                Display remote working directory\nquit                               Quit sftp\nreget [-fpR] remote [local]        Resume download file\nrename oldpath newpath             Rename remote file\nreput [-fpR] local [remote]        Resume upload file\nrm path                            Delete remote file\nrmdir path                         Remove remote directory\nsymlink oldpath newpath            Symlink remote file\nversion                            Show SFTP version\n!command                           Execute 'command' in local shell\n!                                  Escape to local shell\n?                                  Synonym for help\n</code></pre>"},{"location":"interactive_cli/#developing-interactive-command-line-applications","title":"Developing Interactive Command-Line Applications","text":"<p>For interactive command-line applications that use custom interaction languages, developers often need to implement their own syntax parsing, which increases development difficulty. Applications that use terminal-like interaction languages have more existing tools available, making development easier. This is also the direction supported by <code>ptcmd</code>.</p> <p>Since we're using terminal-like interaction languages, can we directly reuse the development toolchain of command-line applications? Undoubtedly, the command-line development toolchain is very mature, with many Python libraries ranging from the standard library's <code>argparse</code> to third-party libraries like <code>click</code> and <code>typer</code>, all allowing developers to quickly build complex command-line applications with multi-level subcommands. However, directly using the command-line development toolchain to create interactive command-line applications presents several problems:</p> <ol> <li>Command-line applications are often designed to exit when encountering errors, which doesn't align with the needs of interactive command-line applications. This behavior is deeply rooted in their implementation and is difficult to change through configuration.</li> <li>The completion mechanisms of command-line applications are developed for terminal environments and cannot be applied to interactive environments.</li> </ol> <p>For interactive applications, Python actually provides a standard library <code>cmd</code> that allows developers to create interactive command-line applications by defining a class that inherits from <code>cmd.Cmd</code> and implementing corresponding methods.</p> <pre><code>import sys\nimport cmd\n\nclass MyCmd(cmd.Cmd):\n    def do_hello(self, args: str) -&gt; None:\n        print(\"Hello, world!\")\n\nif __name__ == '__main__':\n    sys.exit(MyCmd().cmdloop())\n</code></pre> <p>However, the <code>cmd</code> library requires manual parameter parsing, doesn't support multi-level subcommands, and only provides completion for command names. This is insufficient for modern interactive applications. The third-party library <code>cmd2</code> addresses some of these issues. As an extension of the <code>cmd</code> library, <code>cmd2</code> is compatible with <code>cmd</code> while providing richer features, such as full command completion via <code>ArgumentParser</code>.</p> <p><code>cmd2</code> can meet most needs for interactive applications, but still has some shortcomings:</p> <ol> <li>Subcommand support is limited; it doesn't support arbitrary multi-level subcommands.</li> <li>Command argument parsing isn't intelligent enough, requiring manual construction of <code>ArgumentParser</code>, which results in significant boilerplate code.</li> <li>Rich text support is lacking; it requires library-specific construction methods and doesn't support more universal libraries like <code>rich</code> (though version 3.X has migrated to <code>rich</code>).</li> </ol> <p>Therefore, <code>ptcmd</code> was born, providing developers with a more modern solution for building interactive command-line applications.</p>"},{"location":"start/","title":"Getting Started","text":""},{"location":"start/#installation","title":"Installation","text":"<p>Install from PyPI (recommended):</p> <pre><code>pip install ptcmd\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/Visecy/ptcmd.git\ncd ptcmd\nmake install\n</code></pre> <p>To run unit tests, use:</p> <pre><code>make develop test\n</code></pre> <p>To build documentation locally, use: <pre><code>make develop docs\n</code></pre></p>"},{"location":"start/#basic-application-structure","title":"Basic Application Structure","text":"<p>ptcmd applications generally follow a consistent pattern: inherit from the <code>Cmd</code> class, define command methods using the <code>do_</code> prefix convention, then create an instance and call the <code>cmdloop()</code> method to start the interaction.</p>"},{"location":"start/#creating-your-first-application","title":"Creating Your First Application","text":"<p>Let's start with the simplest application:</p> <pre><code>import sys\nfrom ptcmd import Cmd\n\nclass MyApp(Cmd):\n    def do_hello(self, argv: list[str]) -&gt; None:\n        \"\"\"Hello World!\"\"\"\n        if argv:\n            name = argv[0]\n        else:\n            name = \"World\"\n        self.poutput(f\"Hello, {name}!\")\n\nif __name__ == \"__main__\":\n    sys.exit(MyApp().cmdloop())\n</code></pre> <p>We defined a class named <code>MyApp</code> that inherits from <code>Cmd</code>, with a single command <code>hello</code>. Now we can run this script:</p> <pre><code>(Cmd) hello\nHello, World!\n(Cmd) hello Alice\nHello, Alice!\n(Cmd) exit\n</code></pre> <p>When we enter the <code>hello</code> command, we get the desired output. Don't forget to enter the <code>exit</code> command to quit the program.</p>"},{"location":"start/#using-declarative-argument-parsing","title":"Using Declarative Argument Parsing","text":"<p>The previous example has a minor issue: it ignores additional arguments. This isn't good practice. We could add conditionals or use <code>argparse</code> to handle this, but these approaches aren't concise and produce boilerplate code.</p> <p><code>ptcmd</code> provides a declarative argument parsing approach that automatically analyzes function signatures to perform argument parsing. This uses the <code>@auto_argument</code> decorator:</p> <pre><code>import sys\nfrom ptcmd import Cmd, auto_argument\n\nclass MyApp(Cmd):\n    @auto_argument\n    def do_hello(self, name: str = \"World\") -&gt; None:\n        \"\"\"Hello World!\"\"\"\n        self.poutput(f\"Hello, {name}!\")\n\nif __name__ == \"__main__\":\n    sys.exit(MyApp().cmdloop())\n</code></pre> <p>Now we've implemented a more robust command with cleaner code. You can use the <code>-h/--help</code> parameter to get command information:</p> <pre><code>(Cmd) hello\nHello, World!\n(Cmd) hello Alice\nHello, Alice!\n(Cmd) hello -h\nUsage: hello [-h] [name]\n\nHello World!\n\nPositional Arguments:\n  name\n\nOptional Arguments:\n  -h, --help  show this help message and exit\n</code></pre>"},{"location":"start/#next-steps","title":"Next Steps","text":"<ul> <li>View the User Guide for more detailed instructions.</li> <li>Explore Examples for additional sample applications.</li> <li>Refer to the API Reference for detailed API definitions.</li> </ul>"},{"location":"api/","title":"API Reference","text":"<ul> <li>ptcmd.argument</li> <li>ptcmd.info</li> <li>ptcmd.command</li> <li>ptcmd.completer</li> <li>ptcmd.core</li> </ul>"},{"location":"api/argument/","title":"ptcmd.argument","text":""},{"location":"api/argument/#ptcmd.argument.Argument","title":"<code>Argument</code>","text":"<p>Represents a command-line argument to be added to an ArgumentParser.</p> <p>This class provides a declarative way to define argparse arguments, either directly or through type annotations using <code>Annotated</code> (aliased as <code>Arg</code> for convenience).</p> <p>It supports all standard argparse argument types and actions, and can be used in type annotations to define command-line arguments in a declarative way.</p> <p>Example usage:</p> <pre><code># Using the Arg alias\nversion: Arg[\n    str,\n    \"-v\", \"--version\",\n    {\"action\": \"version\", \"version\": \"0.1.0\"}\n]\n\n# Using Annotated with Argument directly\nversion: Annotated[\n    str,\n    Argument(\n        \"-v\", \"--version\",\n        action=\"version\",\n        version=\"0.1.0\"\n    )\n]\n</code></pre> Source code in <code>src/ptcmd/argument.py</code> <pre><code>class Argument:\n    \"\"\"Represents a command-line argument to be added to an ArgumentParser.\n\n    This class provides a declarative way to define argparse arguments, either directly\n    or through type annotations using `Annotated` (aliased as `Arg` for convenience).\n\n    It supports all standard argparse argument types and actions, and can be used in\n    type annotations to define command-line arguments in a declarative way.\n\n    Example usage:\n\n    ```python linenums=\"1\"\n    # Using the Arg alias\n    version: Arg[\n        str,\n        \"-v\", \"--version\",\n        {\"action\": \"version\", \"version\": \"0.1.0\"}\n    ]\n\n    # Using Annotated with Argument directly\n    version: Annotated[\n        str,\n        Argument(\n            \"-v\", \"--version\",\n            action=\"version\",\n            version=\"0.1.0\"\n        )\n    ]\n    ```\n    \"\"\"\n\n    __slots__ = [\"args\", \"kwargs\", \"_param\"]\n\n    if TYPE_CHECKING:\n\n        def __init__(\n            self,\n            *name_or_flags: str,\n            skip: bool = ...,\n            action: Union[str, Type[Action]] = ...,\n            nargs: Union[int, str, None] = None,\n            const: Any = ...,\n            default: Any = ...,\n            type: Union[Callable[[str], Any], FileType, str] = ...,\n            choices: Iterable[Any] = ...,\n            required: bool = ...,\n            help: Optional[str] = ...,\n            metavar: Union[str, Tuple[str, ...], None] = ...,\n            dest: Optional[str] = ...,\n            version: str = ...,\n            **kwargs: Any,\n        ) -&gt; None: ...\n    else:\n\n        def __init__(self, *args: str, **kwds: Any) -&gt; None:\n            \"\"\"Initialize an Argument instance with names/flags and keyword arguments.\n\n            :param args: Positional arguments (names/flags) for the argument\n            :type args: str\n            :param kwds: Keyword arguments for the argument\n            :type kwds: Any\n            \"\"\"\n            self.args = args\n            self.kwargs = kwds\n            if \"skip\" in self.kwargs and not self.kwargs[\"skip\"]:\n                self.kwargs.pop(\"skip\")\n            self._param = None\n\n    def bind(self, param: Parameter) -&gt; None:\n        \"\"\"Bind an Argument instance to a Parameter instance.\n\n        :param param: The Parameter instance to bind to the argument\n        :type param: Parameter\n        :raises ValueError: argument already bound\n        :raises TypeError: argument cannot be used with **kwargs\n        \"\"\"\n        if self._param is not None and param != self._param:  # pragma: no cover\n            raise ValueError(\"argument already bound\")\n        elif param.kind == Parameter.VAR_KEYWORD:  # pragma: no cover\n            raise TypeError(f\"argument cannot be used with **{param.name}\")\n\n        self._param = param\n        if not self.args:\n            name = param.name\n            if param.kind == Parameter.KEYWORD_ONLY:\n                if len(name) == 1:\n                    name = f\"-{name}\"\n                else:\n                    name = f\"--{name.replace('_', '-')}\"\n            self.args = (name,)\n\n        if param.kind == Parameter.VAR_POSITIONAL:\n            self.kwargs[\"nargs\"] = \"*\"\n        elif param.kind == Parameter.KEYWORD_ONLY:\n            self.kwargs[\"dest\"] = param.name\n        elif param.default is not Parameter.empty:\n            self.kwargs[\"nargs\"] = '?'\n\n        if param.kind == Parameter.KEYWORD_ONLY and self.kwargs.get(\"type\") is bool:\n            if param.default is True:\n                self.kwargs[\"action\"] = \"store_false\"\n            else:\n                self.kwargs[\"action\"] = \"store_true\"\n            self.kwargs.pop(\"type\")\n        if param.default is not Parameter.empty and self.kwargs.get(\"action\") not in (\"store_true\", \"store_false\"):\n            self.kwargs[\"default\"] = param.default\n\n    def __class_getitem__(cls, args: Any) -&gt; Annotated:\n        \"\"\"Create an Annotated type with Argument metadata for type annotations.\n\n        This enables the Argument class to be used in type annotations to define\n        command-line arguments in a declarative way.\n\n        Additionally, if the type is a `Literal`, the choices will be automatically\n        set to the values in the Literal, unless the `choices` keyword is explicitly provided.\n\n        :param args: Either:\n            - A single type (e.g. `Argument[str]`)\n            - A tuple of (type, *names, Argument) (e.g. `Argument[str, \"-f\", \"--file\"]`)\n            - A tuple of (type, *names, dict) (e.g. `Argument[str, \"-f\", {\"help\": \"file\"}]`)\n        :type args: Any\n        :return: An Annotated type containing the argument specification\n        :rtype: Annotated\n        :raises TypeError: If argument names are not strings\n        \"\"\"\n        if not isinstance(args, tuple):\n            tp = args\n            args = ()\n        else:\n            tp, *args = args\n\n        if args and isinstance(args[-1], cls):\n            arg_ins: Self\n            *args, arg_ins = args\n            args = tuple(args) + arg_ins.args\n            kwargs = arg_ins.kwargs\n        elif args and isinstance(args[-1], Mapping):\n            *args, kwargs = args\n            if \"type\" not in kwargs and \"action\" not in kwargs and _is_valid_argparse_type(tp):\n                kwargs[\"type\"] = tp\n        elif _is_valid_argparse_type(tp):\n            kwargs = {\"type\": tp}\n        else:\n            kwargs = {}\n\n        # Automatically set choices from Literal type\n        origin = get_origin(tp)\n        if origin is Literal:\n            literal_choices = get_args(tp)\n            # Only set choices if not explicitly provided\n            if \"choices\" not in kwargs:\n                kwargs[\"choices\"] = literal_choices\n\n        if not all(isinstance(arg, str) for arg in args):  # pragma: no cover\n            raise TypeError(\"argument name must be str\")\n        return Annotated[tp, cls(*args, **kwargs)]  # type: ignore\n\n    def __call__(self, parser: ArgumentParser) -&gt; ArgumentParser:\n        \"\"\"Add this argument to an ArgumentParser instance.\n\n        This implements the callable interface that allows Argument instances to be\n        used directly with ArgumentParser.add_argument().\n\n        :param parser: The ArgumentParser to modify\n        :type parser: ArgumentParser\n        :return: The modified ArgumentParser (for method chaining)\n        :rtype: ArgumentParser\n        \"\"\"\n        if not self.kwargs.get(\"skip\", False):\n            parser.add_argument(*self.args, **self.kwargs)\n        return parser\n\n    def __eq__(self, value: Any) -&gt; bool:\n        if not isinstance(value, self.__class__):  # pragma: no cover\n            return False\n        return self.args == value.args and self.kwargs == value.kwargs\n\n    __hash__ = object.__hash__\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Generate a developer-friendly string representation of the Argument.\n\n        The representation includes the class name and all argument configuration\n        (names/flags and keyword arguments).\n\n        :return: String representation showing argument configuration\n        :rtype: str\n        \"\"\"\n        return f\"{self.__class__.__qualname__}({self.args}, {self.kwargs})\"\n</code></pre>"},{"location":"api/argument/#ptcmd.argument.Argument.__call__","title":"<code>__call__(parser)</code>","text":"<p>Add this argument to an ArgumentParser instance.</p> <p>This implements the callable interface that allows Argument instances to be used directly with ArgumentParser.add_argument().</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The ArgumentParser to modify</p> required <p>Returns:</p> Type Description <code>ArgumentParser</code> <p>The modified ArgumentParser (for method chaining)</p> Source code in <code>src/ptcmd/argument.py</code> <pre><code>def __call__(self, parser: ArgumentParser) -&gt; ArgumentParser:\n    \"\"\"Add this argument to an ArgumentParser instance.\n\n    This implements the callable interface that allows Argument instances to be\n    used directly with ArgumentParser.add_argument().\n\n    :param parser: The ArgumentParser to modify\n    :type parser: ArgumentParser\n    :return: The modified ArgumentParser (for method chaining)\n    :rtype: ArgumentParser\n    \"\"\"\n    if not self.kwargs.get(\"skip\", False):\n        parser.add_argument(*self.args, **self.kwargs)\n    return parser\n</code></pre>"},{"location":"api/argument/#ptcmd.argument.Argument.__class_getitem__","title":"<code>__class_getitem__(args)</code>","text":"<p>Create an Annotated type with Argument metadata for type annotations.</p> <p>This enables the Argument class to be used in type annotations to define command-line arguments in a declarative way.</p> <p>Additionally, if the type is a <code>Literal</code>, the choices will be automatically set to the values in the Literal, unless the <code>choices</code> keyword is explicitly provided.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>Either: - A single type (e.g. <code>Argument[str]</code>) - A tuple of (type, names, Argument) (e.g. <code>Argument[str, \"-f\", \"--file\"]</code>) - A tuple of (type, names, dict) (e.g. <code>Argument[str, \"-f\", {\"help\": \"file\"}]</code>)</p> required <p>Returns:</p> Type Description <code>Annotated</code> <p>An Annotated type containing the argument specification</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If argument names are not strings</p> Source code in <code>src/ptcmd/argument.py</code> <pre><code>def __class_getitem__(cls, args: Any) -&gt; Annotated:\n    \"\"\"Create an Annotated type with Argument metadata for type annotations.\n\n    This enables the Argument class to be used in type annotations to define\n    command-line arguments in a declarative way.\n\n    Additionally, if the type is a `Literal`, the choices will be automatically\n    set to the values in the Literal, unless the `choices` keyword is explicitly provided.\n\n    :param args: Either:\n        - A single type (e.g. `Argument[str]`)\n        - A tuple of (type, *names, Argument) (e.g. `Argument[str, \"-f\", \"--file\"]`)\n        - A tuple of (type, *names, dict) (e.g. `Argument[str, \"-f\", {\"help\": \"file\"}]`)\n    :type args: Any\n    :return: An Annotated type containing the argument specification\n    :rtype: Annotated\n    :raises TypeError: If argument names are not strings\n    \"\"\"\n    if not isinstance(args, tuple):\n        tp = args\n        args = ()\n    else:\n        tp, *args = args\n\n    if args and isinstance(args[-1], cls):\n        arg_ins: Self\n        *args, arg_ins = args\n        args = tuple(args) + arg_ins.args\n        kwargs = arg_ins.kwargs\n    elif args and isinstance(args[-1], Mapping):\n        *args, kwargs = args\n        if \"type\" not in kwargs and \"action\" not in kwargs and _is_valid_argparse_type(tp):\n            kwargs[\"type\"] = tp\n    elif _is_valid_argparse_type(tp):\n        kwargs = {\"type\": tp}\n    else:\n        kwargs = {}\n\n    # Automatically set choices from Literal type\n    origin = get_origin(tp)\n    if origin is Literal:\n        literal_choices = get_args(tp)\n        # Only set choices if not explicitly provided\n        if \"choices\" not in kwargs:\n            kwargs[\"choices\"] = literal_choices\n\n    if not all(isinstance(arg, str) for arg in args):  # pragma: no cover\n        raise TypeError(\"argument name must be str\")\n    return Annotated[tp, cls(*args, **kwargs)]  # type: ignore\n</code></pre>"},{"location":"api/argument/#ptcmd.argument.Argument.__init__","title":"<code>__init__(*args, **kwds)</code>","text":"<p>Initialize an Argument instance with names/flags and keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>str</code> <p>Positional arguments (names/flags) for the argument</p> <code>()</code> <code>kwds</code> <code>Any</code> <p>Keyword arguments for the argument</p> <code>{}</code> Source code in <code>src/ptcmd/argument.py</code> <pre><code>def __init__(self, *args: str, **kwds: Any) -&gt; None:\n    \"\"\"Initialize an Argument instance with names/flags and keyword arguments.\n\n    :param args: Positional arguments (names/flags) for the argument\n    :type args: str\n    :param kwds: Keyword arguments for the argument\n    :type kwds: Any\n    \"\"\"\n    self.args = args\n    self.kwargs = kwds\n    if \"skip\" in self.kwargs and not self.kwargs[\"skip\"]:\n        self.kwargs.pop(\"skip\")\n    self._param = None\n</code></pre>"},{"location":"api/argument/#ptcmd.argument.Argument.__repr__","title":"<code>__repr__()</code>","text":"<p>Generate a developer-friendly string representation of the Argument.</p> <p>The representation includes the class name and all argument configuration (names/flags and keyword arguments).</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation showing argument configuration</p> Source code in <code>src/ptcmd/argument.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Generate a developer-friendly string representation of the Argument.\n\n    The representation includes the class name and all argument configuration\n    (names/flags and keyword arguments).\n\n    :return: String representation showing argument configuration\n    :rtype: str\n    \"\"\"\n    return f\"{self.__class__.__qualname__}({self.args}, {self.kwargs})\"\n</code></pre>"},{"location":"api/argument/#ptcmd.argument.Argument.bind","title":"<code>bind(param)</code>","text":"<p>Bind an Argument instance to a Parameter instance.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>Parameter</code> <p>The Parameter instance to bind to the argument</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>argument already bound</p> <code>TypeError</code> <p>argument cannot be used with **kwargs</p> Source code in <code>src/ptcmd/argument.py</code> <pre><code>def bind(self, param: Parameter) -&gt; None:\n    \"\"\"Bind an Argument instance to a Parameter instance.\n\n    :param param: The Parameter instance to bind to the argument\n    :type param: Parameter\n    :raises ValueError: argument already bound\n    :raises TypeError: argument cannot be used with **kwargs\n    \"\"\"\n    if self._param is not None and param != self._param:  # pragma: no cover\n        raise ValueError(\"argument already bound\")\n    elif param.kind == Parameter.VAR_KEYWORD:  # pragma: no cover\n        raise TypeError(f\"argument cannot be used with **{param.name}\")\n\n    self._param = param\n    if not self.args:\n        name = param.name\n        if param.kind == Parameter.KEYWORD_ONLY:\n            if len(name) == 1:\n                name = f\"-{name}\"\n            else:\n                name = f\"--{name.replace('_', '-')}\"\n        self.args = (name,)\n\n    if param.kind == Parameter.VAR_POSITIONAL:\n        self.kwargs[\"nargs\"] = \"*\"\n    elif param.kind == Parameter.KEYWORD_ONLY:\n        self.kwargs[\"dest\"] = param.name\n    elif param.default is not Parameter.empty:\n        self.kwargs[\"nargs\"] = '?'\n\n    if param.kind == Parameter.KEYWORD_ONLY and self.kwargs.get(\"type\") is bool:\n        if param.default is True:\n            self.kwargs[\"action\"] = \"store_false\"\n        else:\n            self.kwargs[\"action\"] = \"store_true\"\n        self.kwargs.pop(\"type\")\n    if param.default is not Parameter.empty and self.kwargs.get(\"action\") not in (\"store_true\", \"store_false\"):\n        self.kwargs[\"default\"] = param.default\n</code></pre>"},{"location":"api/argument/#ptcmd.argument.build_parser","title":"<code>build_parser(func, *, unannotated_mode='strict', parser_factory=ArgumentParser)</code>","text":"<p>Construct an ArgumentParser from a function's signature and type annotations.</p> <p>This function analyzes the function's parameters and their type annotations to automatically configure an ArgumentParser. Parameters annotated with <code>Arg</code> or <code>Annotated[..., Argument(...)]</code> will be converted to command-line arguments.</p> <p>Key features: 1. Automatically handles positional vs optional arguments based on parameter kind 2. Supports all standard argparse argument types and actions 3. Provides flexible handling of unannotated parameters via unannotated_mode 4. Preserves function docstring as parser description</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Union[Callable, Signature]</code> <p>The function or its signature to analyze</p> required <code>unannotated_mode</code> <code>Literal['strict', 'autoconvert', 'ignore']</code> <p>Determines behavior for parameters without Argument metadata: * \"strict\": Raises TypeError (default) * \"autoconvert\": Attempts to infer Argument from type annotation * \"ignore\": Silently skips unannotated parameters</p> <code>'strict'</code> <code>parser_factory</code> <code>Callable[[], _T_Parser]</code> <p>Custom factory for creating the parser instance</p> <code>ArgumentParser</code> <p>Returns:</p> Type Description <code>_T_Parser</code> <p>Fully configured ArgumentParser instance</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>For invalid parameter kinds or strict mode violations</p> <code>ValueError</code> <p>For invalid unannotated_mode values  Example: <code>python linenums=\"1\" def example( path: Arg[str, \"--path\", {\"help\": \"Input path\"}], force: Arg[bool, \"--force\", {\"action\": \"store_true\"}], *, timeout: int = 10, ) -&gt; None: ...  parser = build_parser(example, unannotated_mode=\"autoconvert\")</code></p> Source code in <code>src/ptcmd/argument.py</code> <pre><code>def build_parser(\n    func: Union[Callable, Signature],\n    *,\n    unannotated_mode: Literal[\"strict\", \"autoconvert\", \"ignore\"] = \"strict\",\n    parser_factory: Callable[[], _T_Parser] = ArgumentParser,\n) -&gt; _T_Parser:\n    \"\"\"Construct an ArgumentParser from a function's signature and type annotations.\n\n    This function analyzes the function's parameters and their type annotations to\n    automatically configure an ArgumentParser. Parameters annotated with `Arg` or\n    `Annotated[..., Argument(...)]` will be converted to command-line arguments.\n\n    Key features:\n    1. Automatically handles positional vs optional arguments based on parameter kind\n    2. Supports all standard argparse argument types and actions\n    3. Provides flexible handling of unannotated parameters via unannotated_mode\n    4. Preserves function docstring as parser description\n\n    :param func: The function or its signature to analyze\n    :type func: Union[Callable, Signature]\n    :param unannotated_mode: Determines behavior for parameters without Argument metadata:\n        * \"strict\": Raises TypeError (default)\n        * \"autoconvert\": Attempts to infer Argument from type annotation\n        * \"ignore\": Silently skips unannotated parameters\n    :type unannotated_mode: Literal[\"strict\", \"autoconvert\", \"ignore\"]\n    :param parser_factory: Custom factory for creating the parser instance\n    :type parser_factory: Callable[..., _T_Parser]\n    :return: Fully configured ArgumentParser instance\n    :rtype: _T_Parser\n    :raises TypeError: For invalid parameter kinds or strict mode violations\n    :raises ValueError: For invalid unannotated_mode values\n\n    Example:\n    ```python linenums=\"1\"\n    def example(\n        path: Arg[str, \"--path\", {\"help\": \"Input path\"}],\n        force: Arg[bool, \"--force\", {\"action\": \"store_true\"}],\n        *,\n        timeout: int = 10,\n    ) -&gt; None: ...\n\n    parser = build_parser(example, unannotated_mode=\"autoconvert\")\n    ```\n    \"\"\"\n    if isinstance(func, Signature):  # pragma: no cover\n        sig = func\n        parser = parser_factory()\n        type_hints = {}\n    else:\n        parser = parser_factory()\n        sig = signature(func)\n        type_hints = get_type_hints(func, include_extras=True)\n\n    for param_name, param in sig.parameters.items():\n        annotation = type_hints.get(param_name, param.annotation)\n        argument = get_argument(annotation)\n        if argument is None:\n            if unannotated_mode == \"strict\":\n                raise TypeError(f\"{param_name} is not annotated with Argument\")\n            elif unannotated_mode == \"autoconvert\":\n                argument = get_argument(Arg[annotation]) if annotation is not Parameter.empty else Argument()\n                if argument is None:  # pragma: no cover\n                    raise TypeError(f\"{param_name} is not annotated with Argument and cannot be inferred from type\")\n            elif unannotated_mode == \"ignore\":\n                continue\n            else:  # pragma: no cover\n                raise ValueError(f\"unsupported unannotated_mode: {unannotated_mode}\")\n\n        argument.bind(param)\n        argument(parser)\n\n    return parser\n</code></pre>"},{"location":"api/argument/#ptcmd.argument.entrypoint","title":"<code>entrypoint(*, unannotated_mode='strict', parser_factory=ArgumentParser)</code>","text":"<p>Decorator that transforms a function into a CLI entry point.</p> <p>The decorated function can be called with an optional argv parameter. When argv is not provided, uses sys.argv[1:].</p> <p>Example:     @entrypoint(unannotated_mode=\"autoconvert\")     def main(path: Arg[str, \"--path\"]):         print(f\"Processing {path}\")</p> <pre><code>if __name__ == \"__main__\":\n    main()  # Uses sys.argv[1:]\n    main([\"--path\", \"test.txt\"])  # Positional argv for testing\n</code></pre> Source code in <code>src/ptcmd/argument.py</code> <pre><code>def entrypoint(\n    *,\n    unannotated_mode: Literal[\"strict\", \"autoconvert\", \"ignore\"] = \"strict\",\n    parser_factory: Callable[[], ArgumentParser] = ArgumentParser,\n) -&gt; Callable[[Callable[..., _T]], Callable[..., _T]]:\n    \"\"\"Decorator that transforms a function into a CLI entry point.\n\n    The decorated function can be called with an optional argv parameter.\n    When argv is not provided, uses sys.argv[1:].\n\n    Example:\n        @entrypoint(unannotated_mode=\"autoconvert\")\n        def main(path: Arg[str, \"--path\"]):\n            print(f\"Processing {path}\")\n\n        if __name__ == \"__main__\":\n            main()  # Uses sys.argv[1:]\n            main([\"--path\", \"test.txt\"])  # Positional argv for testing\n    \"\"\"\n    def decorator(func: Callable[..., _T]) -&gt; Callable[..., _T]:\n        @wraps(func)\n        def wrapper(argv: Optional[Sequence[str]] = None) -&gt; _T:\n            actual_argv = argv if argv is not None else sys.argv[1:]\n            return invoke_from_argv(\n                func,\n                actual_argv,\n                unannotated_mode=unannotated_mode,\n                parser_factory=parser_factory\n            )\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"api/argument/#ptcmd.argument.get_argument","title":"<code>get_argument(annotation)</code>","text":"<p>Extract an Argument instance from a type annotation.</p> <p>This helper function checks if the annotation is either: 1. An Argument instance directly 2. An Annotated type containing an Argument in its metadata</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Any</code> <p>The type annotation to inspect</p> required <p>Returns:</p> Type Description <code>Optional[Argument]</code> <p>The extracted Argument if found, None otherwise</p> Source code in <code>src/ptcmd/argument.py</code> <pre><code>def get_argument(annotation: Any) -&gt; Optional[Argument]:\n    \"\"\"Extract an Argument instance from a type annotation.\n\n    This helper function checks if the annotation is either:\n    1. An Argument instance directly\n    2. An Annotated type containing an Argument in its metadata\n\n    :param annotation: The type annotation to inspect\n    :type annotation: Any\n    :return: The extracted Argument if found, None otherwise\n    :rtype: Optional[Argument]\n    \"\"\"\n    if isinstance(annotation, Argument):  # pragma: no cover\n        return annotation\n    if get_origin(annotation) is not Annotated:\n        return\n\n    _, *metadata = get_args(annotation)\n    for arg in metadata:\n        if isinstance(arg, Argument):\n            return arg\n</code></pre>"},{"location":"api/argument/#ptcmd.argument.invoke_from_argv","title":"<code>invoke_from_argv(func, argv, *, unannotated_mode='strict', parser_factory=ArgumentParser)</code>","text":"<p>Invoke the command with parsed arguments from a list of argv strings.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., _T]</code> <p>The wrapped function to execute</p> required <code>argv</code> <code>Sequence[str]</code> <p>List of argument strings to parse</p> required <code>unannotated_mode</code> <code>Literal['strict', 'autoconvert', 'ignore']</code> <p>Determines behavior for parameters without Argument metadata: * \"strict\": Raises TypeError (default) * \"autoconvert\": Attempts to infer Argument from type annotation * \"ignore\": Silently skips unannotated parameters</p> <code>'strict'</code> <code>parser_factory</code> <code>Callable[[], ArgumentParser]</code> <p>Custom factory for creating the parser instance</p> <code>ArgumentParser</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the wrapped function</p> Source code in <code>src/ptcmd/argument.py</code> <pre><code>def invoke_from_argv(\n    func: Callable[..., _T],\n    argv: Sequence[str],\n    *,\n    unannotated_mode: Literal[\"strict\", \"autoconvert\", \"ignore\"] = \"strict\",\n    parser_factory: Callable[[], ArgumentParser] = ArgumentParser,\n) -&gt; _T:\n    \"\"\"Invoke the command with parsed arguments from a list of argv strings.\n\n    :param func: The wrapped function to execute\n    :type func: Callable[..., _T]\n    :param argv: List of argument strings to parse\n    :type argv: List[str]\n    :param unannotated_mode: Determines behavior for parameters without Argument metadata:\n        * \"strict\": Raises TypeError (default)\n        * \"autoconvert\": Attempts to infer Argument from type annotation\n        * \"ignore\": Silently skips unannotated parameters\n    :type unannotated_mode: Literal[\"strict\", \"autoconvert\", \"ignore\"]\n    :param parser_factory: Custom factory for creating the parser instance\n    :type parser_factory: Callable[..., _T_Parser]\n    :return: The result of the wrapped function\n    :rtype: Any\n    \"\"\"\n    parser = build_parser(func, unannotated_mode=unannotated_mode, parser_factory=parser_factory)\n    ns = parser.parse_args(argv)\n    return invoke_from_ns(func, ns)\n</code></pre>"},{"location":"api/argument/#ptcmd.argument.invoke_from_ns","title":"<code>invoke_from_ns(func, ns)</code>","text":"<p>Execute the actual command function with arguments from namespace.</p> <p>This method extracts arguments from the namespace and calls the wrapped function with appropriate positional and keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., _T]</code> <p>The wrapped function to execute</p> required <code>ns</code> <code>Namespace</code> <p>The parsed argument namespace</p> required <p>Returns:</p> Type Description <code>_T</code> <p>The result of the wrapped function</p> Source code in <code>src/ptcmd/argument.py</code> <pre><code>def invoke_from_ns(func: Callable[..., _T], ns: Namespace) -&gt; _T:\n    \"\"\"Execute the actual command function with arguments from namespace.\n\n    This method extracts arguments from the namespace and calls the\n    wrapped function with appropriate positional and keyword arguments.\n\n    :param func: The wrapped function to execute\n    :type func: Callable[..., _T]\n    :param ns: The parsed argument namespace\n    :type ns: Namespace\n    :return: The result of the wrapped function\n    :rtype: _T\n    \"\"\"\n    sig = signature(func)\n    args, kwargs = [], {}\n    for param_name, param in sig.parameters.items():\n        if param.kind == Parameter.VAR_POSITIONAL:\n            args.extend(getattr(ns, param_name, []))\n        elif param.kind == Parameter.VAR_KEYWORD:\n            kwargs.update(getattr(ns, param_name, {}))\n        elif param.kind == Parameter.KEYWORD_ONLY:\n            kwargs[param_name] = getattr(ns, param_name)\n        else:\n            args.append(getattr(ns, param_name))\n    return func(*args, **kwargs)\n</code></pre>"},{"location":"api/command/","title":"ptcmd.command","text":"<p>Command decorators and classes for ptcmd.</p> <p>This module provides the core functionality for creating and managing commands with automatic argument parsing and completion.</p>"},{"location":"api/command/#ptcmd.command.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>Generic[_P, _T]</code></p> <p>Wrapper class that adds command metadata and argument parsing to a function.</p> <p>This class serves as the core command implementation in ptcmd, providing: - Automatic argument parsing from function signatures - Command metadata (name, hidden status, disabled status) - Argument completion support - Method binding for instance commands - Subcommand management</p> <p>The Command class is typically created through the @auto_argument decorator rather than being instantiated directly.</p> Source code in <code>src/ptcmd/command.py</code> <pre><code>class Command(Generic[_P, _T]):\n    \"\"\"Wrapper class that adds command metadata and argument parsing to a function.\n\n    This class serves as the core command implementation in ptcmd, providing:\n    - Automatic argument parsing from function signatures\n    - Command metadata (name, hidden status, disabled status)\n    - Argument completion support\n    - Method binding for instance commands\n    - Subcommand management\n\n    The Command class is typically created through the @auto_argument decorator\n    rather than being instantiated directly.\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable[_P, _T],\n        *,\n        cmd_name: Optional[str] = None,\n        parser: Optional[ArgumentParser] = None,\n        unannotated_mode: Literal[\"strict\", \"autoconvert\", \"ignore\"] = \"autoconvert\",\n        parser_factory: Optional[Callable[[], ArgumentParser]] = None,\n        help_category: Optional[str] = None,\n        hidden: bool = False,\n        disabled: bool = False,\n        _parent: Optional[\"Command\"] = None,\n    ) -&gt; None:\n        update_wrapper(self, func)\n        self._parent = _parent\n        self.__func__ = func\n        if parser is None:\n            if parser_factory is None:\n                parser_factory = partial(\n                    ArgumentParser, prog=func.__name__, description=func.__doc__, formatter_class=RichHelpFormatter\n                )\n            parser = build_parser(\n                MethodType(self.__func__, object()),\n                unannotated_mode=unannotated_mode,\n                parser_factory=parser_factory,\n            )\n            if cmd_name is not None:\n                parser.prog = cmd_name\n        self.cmd_name = cmd_name\n        self.parser = parser\n        self.parser.set_defaults(__cmd_ins__=self)\n        self.help_category = help_category\n        self.hidden = hidden\n        self.disabled = disabled\n        self._completer_getter = None\n\n    @overload\n    def add_subcommand(\n        self,\n        name: str,\n        func: None = None,\n        *,\n        help: Optional[str] = None,\n        aliases: Sequence[str] = (),\n        add_help: bool = True,\n        unannotated_mode: Literal[\"strict\", \"autoconvert\", \"ignore\"] = \"autoconvert\",\n        help_category: Optional[str] = None,\n        hidden: bool = False,\n        disabled: bool = False,\n    ) -&gt; Callable[[Callable[_P_Subcmd, _T_Subcmd]], \"Command[_P_Subcmd, _T_Subcmd]\"]:\n        ...\n\n    @overload\n    def add_subcommand(\n        self,\n        name: str,\n        func: Callable[_P_Subcmd, _T_Subcmd],\n        *,\n        help: Optional[str] = None,\n        aliases: Sequence[str] = (),\n        add_help: bool = True,\n        unannotated_mode: Literal[\"strict\", \"autoconvert\", \"ignore\"] = \"autoconvert\",\n        help_category: Optional[str] = None,\n        hidden: bool = False,\n        disabled: bool = False,\n    ) -&gt; \"Command[_P_Subcmd, _T_Subcmd]\":\n        ...\n\n    def add_subcommand(\n        self,\n        name: str,\n        func: Optional[Callable[_P_Subcmd, _T_Subcmd]] = None,\n        *,\n        help: Optional[str] = None,\n        aliases: Sequence[str] = (),\n        add_help: bool = True,\n        **kwds: Any,\n    ) -&gt; Union[Callable[[Callable[_P_Subcmd, _T_Subcmd]], \"Command[_P_Subcmd, _T_Subcmd]\"], \"Command[_P_Subcmd, _T_Subcmd]\"]:\n        \"\"\"Add a subcommand to this command.\n\n        This method can be used as a decorator or directly with a function.\n        It creates a nested command structure where the current command acts as a parent.\n\n        :param name: Name of the subcommand\n        :type name: str\n        :param func: The function to wrap as a subcommand (if provided directly)\n        :type func: Optional[Callable[_P_Subcmd, _T_Subcmd]]\n        :param help: Help text for the subcommand\n        :type help: Optional[str]\n        :param aliases: Aliases for the subcommand\n        :type aliases: Sequence[str]\n        :param add_help: Whether to add help for the subcommand\n        :type add\u6781_help: bool\n        :param kwds: Additional keyword arguments for the Command constructor\n        :type kwds: Any\n        :return: Either a decorator function or a Command instance\n        :rtype: Union[Callable[[Callable[_P_Subcmd, _T_Subcmd]], Command[_P_Subcmd, _T_Subcmd]], Command[_P_Subcmd, _T_Subcmd]]\n        \"\"\"\n        subparser_action = self._ensure_subparsers()\n        def inner(inner: Callable[_P_Subcmd, _T_Subcmd]) -&gt; \"Command[_P_Subcmd, _T_Subcmd]\":\n            if isinstance(func, Command):  # pragma: no cover\n                raise TypeError(\"add_subcommand cannot be used with Command instances directly\")\n            return cast(Type[Command], self.__class__)(\n                inner,\n                cmd_name=None,\n                parser_factory=partial(\n                    subparser_action.add_parser,\n                    name,\n                    help=help,\n                    aliases=aliases,\n                    add_help=add_help,\n                    description=inner.__doc__,\n                    formatter_class=RichHelpFormatter,\n                ),\n                parser=None,\n                _parent=self,\n                **kwds,\n            )\n        if func is None:\n            return inner\n        else:\n            return inner(func)\n\n    def completer_getter(self, func: CompleterGetterFunc) -&gt; CompleterGetterFunc:\n        \"\"\"Decorator to set a custom completer getter function for this command.\n\n        The completer getter function should accept a BaseCmd instance and return a Completer.\n\n        :param func: The completer getter function\n        :type func: CompleterGetterFunc\n        :return: The same function (for decorator chaining)\n        :rtype: CompleterGetterFunc\n        \"\"\"\n        self._completer_getter = func\n        return func\n\n    def invoke_from_argv(self, cmd: \"BaseCmd\", argv: List[str], *, parser: Optional[ArgumentParser] = None) -&gt; Any:\n        \"\"\"Invoke the command with parsed arguments from a list of argv strings.\n\n        This method parses command-line arguments and invokes the command function.\n        It handles redirecting stdin/stdout during argument parsing.\n\n        :param cmd: The BaseCmd instance this command belongs to\n        :type cmd: \"BaseCmd\"\n        :param argv: List of argument strings to parse\n        :type argv: List[str]\n        :param parser: Optional ArgumentParser to use (default: self.parser)\n        :type parser: Optional[ArgumentParser]\n        :return: The result of the wrapped function\n        :rtype: Any\n        \"\"\"\n        if parser is None:\n            parser = self.parser\n        argv = [\n            literal_eval(arg)\n            if (arg.startswith('\"') and arg.endswith('\"')) or (arg.startswith(\"'\") and arg.endswith(\"'\"))\n            else arg\n            for arg in argv\n        ]\n        try:\n            ns = parser.parse_args(argv)\n        except SystemExit:\n            return\n        return self.invoke_from_ns(cmd, ns)\n\n    def invoke_from_ns(self, cmd: \"BaseCmd\", ns: Namespace) -&gt; Any:\n        \"\"\"Invoke the command from a parsed namespace object.\n\n        This method handles nested command invocation by traversing the command chain.\n\n        :param cmd: The BaseCmd instance this command belongs to\n        :type cmd: \"BaseCmd\"\n        :param ns: The parsed argument namespace\n        :type ns: Namespace\n        :return: The result of the wrapped function\n        :rtype: Any\n        \"\"\"\n        cmd_ins = getattr(ns, \"__cmd_ins__\", self)\n        cmd_chain = [cmd_ins]\n        while cmd_ins._parent is not None and cmd_ins is not self:\n            cmd_ins = cmd_ins._parent\n            cmd_chain.append(cmd_ins)\n        assert cmd_ins is self, f\"Command chain is broken(root={cmd_ins})\"\n\n        ns.__cmd_chain__ = cmd_chain\n        ret = None\n        while cmd_chain:\n            cmd_ins = cmd_chain.pop()\n            ns.__cmd_result__ = ret\n            ret = invoke_from_ns(MethodType(cmd_ins, cmd), ns)\n        return ret\n\n    def _ensure_subparsers(self) -&gt; _SubParsersAction:\n        \"\"\"Ensure the command parser has a subparsers action.\n\n        If the parser already has a subparsers action, return it.\n        Otherwise, create a new one and return it.\n\n        :return: The subparsers action for this command\n        :rtype: _SubParsersAction\n        \"\"\"\n        for action in self.parser._actions:\n            if isinstance(action, _SubParsersAction):\n                return action\n        return self.parser.add_subparsers(metavar='SUBCOMMAND', required=True)\n\n    @overload\n    def __get__(self, instance: None, owner: Optional[type]) -&gt; Self: ...\n\n    @overload\n    def __get__(\n        self: \"Command[Concatenate[Any, _P_Method], _T]\", instance: object, owner: Optional[type]\n    ) -&gt; Callable[_P_Method, _T]: ...\n\n    def __get__(self, instance: Optional[object], owner: Optional[type]) -&gt; Callable[..., _T]:\n        \"\"\"Descriptor protocol implementation for method binding.\n\n        This allows Command instances to behave like methods when accessed\n        through a class instance.\n\n        :param instance: The instance accessing the descriptor (None for class access)\n        :type instance: Optional[object]\n        :param owner: The class that owns the descriptor\n        :type owner: Optional[type]\n        :return: Either the Command instance or a bound method\n        :rtype: Union[\"Command[_P, _T]\", Callable[_P, _T]]\n        \"\"\"\n        if instance is None:\n            return self\n        return self.__func__.__get__(instance, owner)\n\n    def __cmd_info__(self, cmd: \"BaseCmd\") -&gt; CommandInfo:\n        \"\"\"Get command information for this command.\n\n        This method implements the CommandInfoGetter protocol, providing\n        metadata about the command for use in help and completion.\n\n        :param cmd: The BaseCmd instance this command belongs to\n        :type cmd: \"BaseCmd\"\n        :return: Command information object\n        :rtype: CommandInfo\n        \"\"\"\n        if self.cmd_name:\n            cmd_name = self.cmd_name\n        else:\n            assert self.__func__.__name__.startswith(cmd.COMMAND_FUNC_PREFIX), f\"{self.__func__} is not a command function\"\n            cmd_name = self.__func__.__name__[len(cmd.COMMAND_FUNC_PREFIX) :]\n        parser = bind_parser(self.parser, cmd_name, cmd)\n        if self._completer_getter is not None:\n            completer = self._completer_getter(cmd)\n        else:\n            completer = ArgparseCompleter(parser)\n        return CommandInfo(\n            name=cmd_name,\n            cmd_func=partial(self.invoke_from_argv, cmd, parser=parser),\n            argparser=parser,\n            completer=completer,\n            category=self.help_category,\n            hidden=self.hidden,\n            disabled=self.disabled,\n        )\n\n    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\n        \"\"\"Call the wrapped function directly.\n\n        This allows Command instances to be used as callable objects.\n\n        :param args: Positional arguments to pass to the wrapped function\n        :type args: _P.args\n        :param kwargs: Keyword arguments to pass to the wrapped function\n        :type kwargs: _P.kwargs\n        :return: The result of the wrapped function\n        :rtype: _T\n        \"\"\"\n        return self.__func__(*args, **kwargs)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return detailed command representation.\n\n        :return: String representation of the command\n        :rtype: str\n        \"\"\"\n        parent_chain = []\n        current = self._parent\n        while current:\n            parent_chain.append(current.cmd_name or \"&lt;root&gt;\")\n            current = current._parent\n\n        return (\n            f\"&lt;Command(name={self.cmd_name!r}, \"\n            f\"func={self.__func__.__name__}, \"\n            f\"parent_chain={parent_chain[::-1]}, \"\n            f\"parser={self.parser.prog if self.parser else None}, \"\n            f\"hidden={self.hidden}, disabled={self.disabled}, \"\n            f\"help_category={self.help_category!r})&gt;\"\n        )\n</code></pre>"},{"location":"api/command/#ptcmd.command.Command.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Call the wrapped function directly.</p> <p>This allows Command instances to be used as callable objects.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>args</code> <p>Positional arguments to pass to the wrapped function</p> <code>()</code> <code>kwargs</code> <code>kwargs</code> <p>Keyword arguments to pass to the wrapped function</p> <code>{}</code> <p>Returns:</p> Type Description <code>_T</code> <p>The result of the wrapped function</p> Source code in <code>src/ptcmd/command.py</code> <pre><code>def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\n    \"\"\"Call the wrapped function directly.\n\n    This allows Command instances to be used as callable objects.\n\n    :param args: Positional arguments to pass to the wrapped function\n    :type args: _P.args\n    :param kwargs: Keyword arguments to pass to the wrapped function\n    :type kwargs: _P.kwargs\n    :return: The result of the wrapped function\n    :rtype: _T\n    \"\"\"\n    return self.__func__(*args, **kwargs)\n</code></pre>"},{"location":"api/command/#ptcmd.command.Command.__cmd_info__","title":"<code>__cmd_info__(cmd)</code>","text":"<p>Get command information for this command.</p> <p>This method implements the CommandInfoGetter protocol, providing metadata about the command for use in help and completion.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>BaseCmd</code> <p>The BaseCmd instance this command belongs to</p> required <p>Returns:</p> Type Description <code>CommandInfo</code> <p>Command information object</p> Source code in <code>src/ptcmd/command.py</code> <pre><code>def __cmd_info__(self, cmd: \"BaseCmd\") -&gt; CommandInfo:\n    \"\"\"Get command information for this command.\n\n    This method implements the CommandInfoGetter protocol, providing\n    metadata about the command for use in help and completion.\n\n    :param cmd: The BaseCmd instance this command belongs to\n    :type cmd: \"BaseCmd\"\n    :return: Command information object\n    :rtype: CommandInfo\n    \"\"\"\n    if self.cmd_name:\n        cmd_name = self.cmd_name\n    else:\n        assert self.__func__.__name__.startswith(cmd.COMMAND_FUNC_PREFIX), f\"{self.__func__} is not a command function\"\n        cmd_name = self.__func__.__name__[len(cmd.COMMAND_FUNC_PREFIX) :]\n    parser = bind_parser(self.parser, cmd_name, cmd)\n    if self._completer_getter is not None:\n        completer = self._completer_getter(cmd)\n    else:\n        completer = ArgparseCompleter(parser)\n    return CommandInfo(\n        name=cmd_name,\n        cmd_func=partial(self.invoke_from_argv, cmd, parser=parser),\n        argparser=parser,\n        completer=completer,\n        category=self.help_category,\n        hidden=self.hidden,\n        disabled=self.disabled,\n    )\n</code></pre>"},{"location":"api/command/#ptcmd.command.Command.__get__","title":"<code>__get__(instance, owner)</code>","text":"<pre><code>__get__(instance: None, owner: Optional[type]) -&gt; Self\n</code></pre><pre><code>__get__(\n    instance: object, owner: Optional[type]\n) -&gt; Callable[_P_Method, _T]\n</code></pre> <p>Descriptor protocol implementation for method binding.</p> <p>This allows Command instances to behave like methods when accessed through a class instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Optional[object]</code> <p>The instance accessing the descriptor (None for class access)</p> required <code>owner</code> <code>Optional[type]</code> <p>The class that owns the descriptor</p> required <p>Returns:</p> Type Description <code>Union[\"Command[_P, _T]\", Callable[_P, _T]]</code> <p>Either the Command instance or a bound method</p> Source code in <code>src/ptcmd/command.py</code> <pre><code>def __get__(self, instance: Optional[object], owner: Optional[type]) -&gt; Callable[..., _T]:\n    \"\"\"Descriptor protocol implementation for method binding.\n\n    This allows Command instances to behave like methods when accessed\n    through a class instance.\n\n    :param instance: The instance accessing the descriptor (None for class access)\n    :type instance: Optional[object]\n    :param owner: The class that owns the descriptor\n    :type owner: Optional[type]\n    :return: Either the Command instance or a bound method\n    :rtype: Union[\"Command[_P, _T]\", Callable[_P, _T]]\n    \"\"\"\n    if instance is None:\n        return self\n    return self.__func__.__get__(instance, owner)\n</code></pre>"},{"location":"api/command/#ptcmd.command.Command.__repr__","title":"<code>__repr__()</code>","text":"<p>Return detailed command representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the command</p> Source code in <code>src/ptcmd/command.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return detailed command representation.\n\n    :return: String representation of the command\n    :rtype: str\n    \"\"\"\n    parent_chain = []\n    current = self._parent\n    while current:\n        parent_chain.append(current.cmd_name or \"&lt;root&gt;\")\n        current = current._parent\n\n    return (\n        f\"&lt;Command(name={self.cmd_name!r}, \"\n        f\"func={self.__func__.__name__}, \"\n        f\"parent_chain={parent_chain[::-1]}, \"\n        f\"parser={self.parser.prog if self.parser else None}, \"\n        f\"hidden={self.hidden}, disabled={self.disabled}, \"\n        f\"help_category={self.help_category!r})&gt;\"\n    )\n</code></pre>"},{"location":"api/command/#ptcmd.command.Command.add_subcommand","title":"<code>add_subcommand(name, func=None, *, help=None, aliases=(), add_help=True, **kwds)</code>","text":"<pre><code>add_subcommand(\n    name: str,\n    func: None = None,\n    *,\n    help: Optional[str] = None,\n    aliases: Sequence[str] = (),\n    add_help: bool = True,\n    unannotated_mode: Literal[\n        \"strict\", \"autoconvert\", \"ignore\"\n    ] = \"autoconvert\",\n    help_category: Optional[str] = None,\n    hidden: bool = False,\n    disabled: bool = False,\n) -&gt; Callable[\n    [Callable[_P_Subcmd, _T_Subcmd]],\n    Command[_P_Subcmd, _T_Subcmd],\n]\n</code></pre><pre><code>add_subcommand(\n    name: str,\n    func: Callable[_P_Subcmd, _T_Subcmd],\n    *,\n    help: Optional[str] = None,\n    aliases: Sequence[str] = (),\n    add_help: bool = True,\n    unannotated_mode: Literal[\n        \"strict\", \"autoconvert\", \"ignore\"\n    ] = \"autoconvert\",\n    help_category: Optional[str] = None,\n    hidden: bool = False,\n    disabled: bool = False,\n) -&gt; Command[_P_Subcmd, _T_Subcmd]\n</code></pre> <p>Add a subcommand to this command.</p> <p>This method can be used as a decorator or directly with a function. It creates a nested command structure where the current command acts as a parent.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the subcommand</p> required <code>func</code> <code>Optional[Callable[_P_Subcmd, _T_Subcmd]]</code> <p>The function to wrap as a subcommand (if provided directly)</p> <code>None</code> <code>help</code> <code>Optional[str]</code> <p>Help text for the subcommand</p> <code>None</code> <code>aliases</code> <code>Sequence[str]</code> <p>Aliases for the subcommand</p> <code>()</code> <code>add_help</code> <code>bool</code> <p>Whether to add help for the subcommand</p> <code>True</code> <code>kwds</code> <code>Any</code> <p>Additional keyword arguments for the Command constructor</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Callable[[Callable[_P_Subcmd, _T_Subcmd]], Command[_P_Subcmd, _T_Subcmd]], Command[_P_Subcmd, _T_Subcmd]]</code> <p>Either a decorator function or a Command instance</p> Source code in <code>src/ptcmd/command.py</code> <pre><code>def add_subcommand(\n    self,\n    name: str,\n    func: Optional[Callable[_P_Subcmd, _T_Subcmd]] = None,\n    *,\n    help: Optional[str] = None,\n    aliases: Sequence[str] = (),\n    add_help: bool = True,\n    **kwds: Any,\n) -&gt; Union[Callable[[Callable[_P_Subcmd, _T_Subcmd]], \"Command[_P_Subcmd, _T_Subcmd]\"], \"Command[_P_Subcmd, _T_Subcmd]\"]:\n    \"\"\"Add a subcommand to this command.\n\n    This method can be used as a decorator or directly with a function.\n    It creates a nested command structure where the current command acts as a parent.\n\n    :param name: Name of the subcommand\n    :type name: str\n    :param func: The function to wrap as a subcommand (if provided directly)\n    :type func: Optional[Callable[_P_Subcmd, _T_Subcmd]]\n    :param help: Help text for the subcommand\n    :type help: Optional[str]\n    :param aliases: Aliases for the subcommand\n    :type aliases: Sequence[str]\n    :param add_help: Whether to add help for the subcommand\n    :type add\u6781_help: bool\n    :param kwds: Additional keyword arguments for the Command constructor\n    :type kwds: Any\n    :return: Either a decorator function or a Command instance\n    :rtype: Union[Callable[[Callable[_P_Subcmd, _T_Subcmd]], Command[_P_Subcmd, _T_Subcmd]], Command[_P_Subcmd, _T_Subcmd]]\n    \"\"\"\n    subparser_action = self._ensure_subparsers()\n    def inner(inner: Callable[_P_Subcmd, _T_Subcmd]) -&gt; \"Command[_P_Subcmd, _T_Subcmd]\":\n        if isinstance(func, Command):  # pragma: no cover\n            raise TypeError(\"add_subcommand cannot be used with Command instances directly\")\n        return cast(Type[Command], self.__class__)(\n            inner,\n            cmd_name=None,\n            parser_factory=partial(\n                subparser_action.add_parser,\n                name,\n                help=help,\n                aliases=aliases,\n                add_help=add_help,\n                description=inner.__doc__,\n                formatter_class=RichHelpFormatter,\n            ),\n            parser=None,\n            _parent=self,\n            **kwds,\n        )\n    if func is None:\n        return inner\n    else:\n        return inner(func)\n</code></pre>"},{"location":"api/command/#ptcmd.command.Command.completer_getter","title":"<code>completer_getter(func)</code>","text":"<p>Decorator to set a custom completer getter function for this command.</p> <p>The completer getter function should accept a BaseCmd instance and return a Completer.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>CompleterGetterFunc</code> <p>The completer getter function</p> required <p>Returns:</p> Type Description <code>CompleterGetterFunc</code> <p>The same function (for decorator chaining)</p> Source code in <code>src/ptcmd/command.py</code> <pre><code>def completer_getter(self, func: CompleterGetterFunc) -&gt; CompleterGetterFunc:\n    \"\"\"Decorator to set a custom completer getter function for this command.\n\n    The completer getter function should accept a BaseCmd instance and return a Completer.\n\n    :param func: The completer getter function\n    :type func: CompleterGetterFunc\n    :return: The same function (for decorator chaining)\n    :rtype: CompleterGetterFunc\n    \"\"\"\n    self._completer_getter = func\n    return func\n</code></pre>"},{"location":"api/command/#ptcmd.command.Command.invoke_from_argv","title":"<code>invoke_from_argv(cmd, argv, *, parser=None)</code>","text":"<p>Invoke the command with parsed arguments from a list of argv strings.</p> <p>This method parses command-line arguments and invokes the command function. It handles redirecting stdin/stdout during argument parsing.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>BaseCmd</code> <p>The BaseCmd instance this command belongs to</p> required <code>argv</code> <code>List[str]</code> <p>List of argument strings to parse</p> required <code>parser</code> <code>Optional[ArgumentParser]</code> <p>Optional ArgumentParser to use (default: self.parser)</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the wrapped function</p> Source code in <code>src/ptcmd/command.py</code> <pre><code>def invoke_from_argv(self, cmd: \"BaseCmd\", argv: List[str], *, parser: Optional[ArgumentParser] = None) -&gt; Any:\n    \"\"\"Invoke the command with parsed arguments from a list of argv strings.\n\n    This method parses command-line arguments and invokes the command function.\n    It handles redirecting stdin/stdout during argument parsing.\n\n    :param cmd: The BaseCmd instance this command belongs to\n    :type cmd: \"BaseCmd\"\n    :param argv: List of argument strings to parse\n    :type argv: List[str]\n    :param parser: Optional ArgumentParser to use (default: self.parser)\n    :type parser: Optional[ArgumentParser]\n    :return: The result of the wrapped function\n    :rtype: Any\n    \"\"\"\n    if parser is None:\n        parser = self.parser\n    argv = [\n        literal_eval(arg)\n        if (arg.startswith('\"') and arg.endswith('\"')) or (arg.startswith(\"'\") and arg.endswith(\"'\"))\n        else arg\n        for arg in argv\n    ]\n    try:\n        ns = parser.parse_args(argv)\n    except SystemExit:\n        return\n    return self.invoke_from_ns(cmd, ns)\n</code></pre>"},{"location":"api/command/#ptcmd.command.Command.invoke_from_ns","title":"<code>invoke_from_ns(cmd, ns)</code>","text":"<p>Invoke the command from a parsed namespace object.</p> <p>This method handles nested command invocation by traversing the command chain.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>BaseCmd</code> <p>The BaseCmd instance this command belongs to</p> required <code>ns</code> <code>Namespace</code> <p>The parsed argument namespace</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The result of the wrapped function</p> Source code in <code>src/ptcmd/command.py</code> <pre><code>def invoke_from_ns(self, cmd: \"BaseCmd\", ns: Namespace) -&gt; Any:\n    \"\"\"Invoke the command from a parsed namespace object.\n\n    This method handles nested command invocation by traversing the command chain.\n\n    :param cmd: The BaseCmd instance this command belongs to\n    :type cmd: \"BaseCmd\"\n    :param ns: The parsed argument namespace\n    :type ns: Namespace\n    :return: The result of the wrapped function\n    :rtype: Any\n    \"\"\"\n    cmd_ins = getattr(ns, \"__cmd_ins__\", self)\n    cmd_chain = [cmd_ins]\n    while cmd_ins._parent is not None and cmd_ins is not self:\n        cmd_ins = cmd_ins._parent\n        cmd_chain.append(cmd_ins)\n    assert cmd_ins is self, f\"Command chain is broken(root={cmd_ins})\"\n\n    ns.__cmd_chain__ = cmd_chain\n    ret = None\n    while cmd_chain:\n        cmd_ins = cmd_chain.pop()\n        ns.__cmd_result__ = ret\n        ret = invoke_from_ns(MethodType(cmd_ins, cmd), ns)\n    return ret\n</code></pre>"},{"location":"api/completer/","title":"ptcmd.completer","text":""},{"location":"api/completer/#ptcmd.completer.ArgparseCompleter","title":"<code>ArgparseCompleter</code>","text":"<p>               Bases: <code>Completer</code></p> <p>Completer for argparse-based commands with advanced completion features.</p> <p>This completer provides sophisticated completion for commands using argparse, including subcommands, argument values, choices, and more.</p> Source code in <code>src/ptcmd/completer.py</code> <pre><code>class ArgparseCompleter(Completer):\n    \"\"\"\n    Completer for argparse-based commands with advanced completion features.\n\n    This completer provides sophisticated completion for commands using argparse,\n    including subcommands, argument values, choices, and more.\n    \"\"\"\n\n    def __init__(self, parser: argparse.ArgumentParser) -&gt; None:\n        \"\"\"\n        Create an Argparse completer for prompt_toolkit.\n\n        :param parser: ArgumentParser instance\n        :type parser: argparse.ArgumentParser\n        \"\"\"\n        self._parser = parser\n        self._flags: List[str] = []  # all flags in this command\n        self._flag_to_action: Dict[str, argparse.Action] = {}  # maps flags to the argparse action object\n        self._positional_actions: List[argparse.Action] = []  # actions for positional arguments\n        self._subcommand_action = None  # set if parser has subcommands\n\n        # Parse argparse actions\n        for action in self._parser._actions:\n            if action.option_strings:  # flag-based arguments\n                for option in action.option_strings:\n                    self._flags.append(option)\n                    self._flag_to_action[option] = action\n            else:  # positional arguments\n                self._positional_actions.append(action)\n                if isinstance(action, argparse._SubParsersAction):\n                    self._subcommand_action = action\n\n    def get_completions(self, document: Document, complete_event: Any) -&gt; Generator[Completion, None, None]:\n        \"\"\"Generate completions as a generator for prompt_toolkit.\"\"\"\n        text = document.text_before_cursor\n        line = document.text\n        cursor_position = document.cursor_position_col\n\n        # Tokenize using shlex\n        for quote in (\"\", '\"', \"'\"):\n            # Handle incomplete quoting\n            try:\n                tokens = shlex.split(text + quote, comments=False, posix=False)\n            except ValueError:\n                continue\n            else:\n                break\n        else:  # pragma: no cover\n            # Revert to whitespace tokenization when shlex fails\n            tokens = text.split()\n\n        # Check if cursor is at end of text with trailing space\n        ends_with_space = text.endswith(\" \")\n\n        # If ends with space, we're completing a new token\n        if ends_with_space:\n            tokens.append(\"\")\n\n        # Get the text to complete (last token)\n        text_to_complete = tokens[-1] if tokens else \"\"\n\n        # Calculate start position for completions\n        start_position = -len(text_to_complete)\n\n        # Yield completions directly from _get_completion_texts\n        yield from self._get_completion_texts(\n            text_to_complete, line, cursor_position - len(text_to_complete), cursor_position, tokens, start_position\n        )\n\n    def _get_completion_texts(\n        self, text: str, line: str, begidx: int, endidx: int, tokens: List[str], start_position: int\n    ) -&gt; Generator[Completion, None, None]:\n        \"\"\"Generate completions by analyzing the command line state.\n\n        :param text: The text being completed (last token)\n        :type text: str\n        :param line: The full command line text\n        :type line: str\n        :param begidx: Beginning index of text in line\n        :type begidx: int\n        :param endidx: Ending index of text in line\n        :type endidx: int\n        :param tokens: List of parsed command tokens\n        :type tokens: List[str]\n        :param start_position: Start position for completions\n        :type start_position: int\n        :return: Generator yielding Completion objects\n        :rtype: Generator[Completion, None, None]\n        \"\"\"\n        remaining_positionals = deque(self._positional_actions)\n        skip_remaining_flags = False\n        pos_arg_state = None\n        flag_arg_state = None\n        matched_flags = []\n        consumed_arg_values: Dict[str, List[str]] = {}\n        # Parse all but last token\n        for token_index, token in enumerate(tokens[:-1]):\n            if pos_arg_state and pos_arg_state.is_remainder:\n                self._consume_argument(pos_arg_state, token, consumed_arg_values)\n                continue\n\n            if flag_arg_state and flag_arg_state.is_remainder:\n                if token == \"--\":\n                    flag_arg_state = None\n                else:\n                    self._consume_argument(flag_arg_state, token, consumed_arg_values)\n                continue\n\n            elif token == \"--\" and not skip_remaining_flags:\n                if flag_arg_state and isinstance(flag_arg_state.min, int) and flag_arg_state.count &lt; flag_arg_state.min:\n                    return\n                flag_arg_state = None\n                skip_remaining_flags = True\n                continue\n\n            if self._looks_like_flag(token) and not skip_remaining_flags:\n                if flag_arg_state and isinstance(flag_arg_state.min, int) and flag_arg_state.count &lt; flag_arg_state.min:\n                    return\n\n                flag_arg_state = None\n                action = None\n\n                if token in self._flag_to_action:\n                    action = self._flag_to_action[token]\n                elif self._parser.allow_abbrev:\n                    candidates = [f for f in self._flag_to_action if f.startswith(token)]\n                    if len(candidates) == 1:\n                        action = self._flag_to_action[candidates[0]]\n\n                if action:\n                    if not isinstance(action, (argparse._AppendAction, argparse._AppendConstAction, argparse._CountAction)):\n                        matched_flags.extend(action.option_strings)\n                        consumed_arg_values[action.dest] = []\n\n                    new_arg_state = self._ArgumentState(action)\n                    if new_arg_state.max &gt; 0:  # type: ignore[operator]\n                        flag_arg_state = new_arg_state\n                        skip_remaining_flags = flag_arg_state.is_remainder\n\n            elif flag_arg_state:\n                self._consume_argument(flag_arg_state, token, consumed_arg_values)\n                if isinstance(flag_arg_state.max, (float, int)) and flag_arg_state.count &gt;= flag_arg_state.max:\n                    flag_arg_state = None\n\n            else:\n                if pos_arg_state is None and remaining_positionals:\n                    action = remaining_positionals.popleft()\n                    if action == self._subcommand_action:\n                        assert self._subcommand_action is not None\n                        if token in self._subcommand_action.choices:\n                            parser = self._subcommand_action.choices[token]\n                            completer = ArgparseCompleter(parser)\n                            yield from completer._get_completion_texts(\n                                text, line, begidx, endidx, tokens[token_index + 1 :], start_position\n                            )\n                        return\n                    else:\n                        pos_arg_state = self._ArgumentState(action)\n\n                if pos_arg_state:\n                    self._consume_argument(pos_arg_state, token, consumed_arg_values)\n                    if pos_arg_state.is_remainder:\n                        skip_remaining_flags = True\n                    elif isinstance(pos_arg_state.max, (float, int)) and pos_arg_state.count &gt;= pos_arg_state.max:\n                        pos_arg_state = None\n                        if remaining_positionals and remaining_positionals[0].nargs == argparse.REMAINDER:\n                            skip_remaining_flags = True\n\n        # Complete last token\n        if self._looks_like_flag(text) and not skip_remaining_flags:\n            if flag_arg_state and isinstance(flag_arg_state.min, int) and flag_arg_state.count &lt; flag_arg_state.min:\n                return\n            yield from self._get_flag_completions(text, matched_flags, start_position)\n            return\n\n        if flag_arg_state:\n            yield from self._get_arg_completions(text, flag_arg_state, consumed_arg_values, start_position)\n            return\n\n        elif pos_arg_state or remaining_positionals:\n            if pos_arg_state is None and remaining_positionals:\n                action = remaining_positionals.popleft()\n                pos_arg_state = self._ArgumentState(action)\n            if pos_arg_state:\n                yield from self._get_arg_completions(text, pos_arg_state, consumed_arg_values, start_position)\n            return\n\n        if not skip_remaining_flags and (self._single_prefix_char(text) or not remaining_positionals):\n            yield from self._get_flag_completions(text, matched_flags, start_position)\n\n    def _get_flag_completions(\n        self, text: str, matched_flags: List[str], start_position: int\n    ) -&gt; Generator[Completion, None, None]:\n        \"\"\"Yield unused flags that match the text.\"\"\"\n        for flag in self._flags:\n            if flag in matched_flags:\n                continue\n            action = self._flag_to_action[flag]\n            if action.help != argparse.SUPPRESS and flag.startswith(text):\n                yield Completion(\n                    text=flag, start_position=start_position, display=flag, display_meta=action.help if action.help else None\n                )\n\n    def _get_arg_completions(\n        self,\n        text: str,\n        arg_state: \"_ArgumentState\",\n        consumed_arg_values: Dict[str, List[str]],\n        start_position: int,\n    ) -&gt; Generator[Completion, None, None]:\n        \"\"\"Yield argument value completions.\"\"\"\n        if arg_state.action.choices is None:\n            return\n        used_values = consumed_arg_values.get(arg_state.action.dest, [])\n        for choice in arg_state.action.choices:\n            choice_str = str(choice)\n            if not choice_str.startswith(text) or choice_str in used_values:\n                continue\n            yield Completion(\n                text=choice_str,\n                start_position=start_position,\n                display=choice_str,\n                display_meta=(\n                    f\"{arg_state.action.metavar} - {arg_state.action.help}\"\n                    if arg_state.action.help\n                    else f\"{arg_state.action.metavar}\"\n                ),\n            )\n\n    def _looks_like_flag(self, token: str) -&gt; bool:\n        \"\"\"Check if token looks like a flag.\"\"\"\n        if len(token) &lt; 1:\n            return False\n        if token[0] not in self._parser.prefix_chars:\n            return False\n        if hasattr(self._parser, \"_negative_number_matcher\"):\n            if self._parser._negative_number_matcher.match(token):\n                if not getattr(self._parser, \"_has_negative_number_optionals\", False):\n                    return False\n        if \" \" in token:\n            return False\n        return True\n\n    def _single_prefix_char(self, token: str) -&gt; bool:\n        \"\"\"Check if token is just a single flag prefix char.\"\"\"\n        return len(token) == 1 and token[0] in self._parser.prefix_chars\n\n    def _consume_argument(self, arg_state: \"_ArgumentState\", token: str, consumed_arg_values: Dict[str, List[str]]) -&gt; None:\n        \"\"\"Record consumption of an argument value.\"\"\"\n        arg_state.count += 1\n        consumed_arg_values.setdefault(arg_state.action.dest, [])\n        consumed_arg_values[arg_state.action.dest].append(token)\n\n    class _ArgumentState:\n        \"\"\"Track state of an argument being parsed.\n\n        This helper class tracks how many values have been consumed for an argument\n        and whether it's a remainder-type argument that consumes all remaining input.\n\n        :ivar action: The argparse Action being tracked\n        :vartype action: argparse.Action\n        :ivar min: Minimum number of values required\n        :vartype min: Union[int, str]\n        :ivar max: Maximum number of values allowed\n        :vartype max: Union[float, int, str]\n        :ivar count: Number of values consumed so far\n        :vartype count: int\n        :ivar is_remainder: Whether this is a remainder argument\n        :vartype is_remainder: bool\n        \"\"\"\n\n        def __init__(self, arg_action: argparse.Action) -&gt; None:\n            self.action = arg_action\n            self.min: Union[int, str]\n            self.max: Union[float, int, str]\n            self.count = 0\n            self.is_remainder = self.action.nargs == argparse.REMAINDER\n\n            nargs_range = getattr(self.action, \"get_nargs_range\", lambda: None)()  # pragma: no cover\n            if nargs_range is not None:  # pragma: no cover\n                self.min, self.max = nargs_range\n            elif self.action.nargs is None:\n                self.min, self.max = 1, 1\n            elif self.action.nargs == argparse.OPTIONAL:\n                self.min, self.max = 0, 1\n            elif self.action.nargs in (argparse.ZERO_OR_MORE, argparse.REMAINDER):\n                self.min, self.max = 0, float(\"inf\")\n            elif self.action.nargs == argparse.ONE_OR_MORE:\n                self.min, self.max = 1, float(\"inf\")\n            else:\n                self.min = self.max = self.action.nargs\n</code></pre>"},{"location":"api/completer/#ptcmd.completer.ArgparseCompleter.__init__","title":"<code>__init__(parser)</code>","text":"<p>Create an Argparse completer for prompt_toolkit.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>ArgumentParser instance</p> required Source code in <code>src/ptcmd/completer.py</code> <pre><code>def __init__(self, parser: argparse.ArgumentParser) -&gt; None:\n    \"\"\"\n    Create an Argparse completer for prompt_toolkit.\n\n    :param parser: ArgumentParser instance\n    :type parser: argparse.ArgumentParser\n    \"\"\"\n    self._parser = parser\n    self._flags: List[str] = []  # all flags in this command\n    self._flag_to_action: Dict[str, argparse.Action] = {}  # maps flags to the argparse action object\n    self._positional_actions: List[argparse.Action] = []  # actions for positional arguments\n    self._subcommand_action = None  # set if parser has subcommands\n\n    # Parse argparse actions\n    for action in self._parser._actions:\n        if action.option_strings:  # flag-based arguments\n            for option in action.option_strings:\n                self._flags.append(option)\n                self._flag_to_action[option] = action\n        else:  # positional arguments\n            self._positional_actions.append(action)\n            if isinstance(action, argparse._SubParsersAction):\n                self._subcommand_action = action\n</code></pre>"},{"location":"api/completer/#ptcmd.completer.ArgparseCompleter.get_completions","title":"<code>get_completions(document, complete_event)</code>","text":"<p>Generate completions as a generator for prompt_toolkit.</p> Source code in <code>src/ptcmd/completer.py</code> <pre><code>def get_completions(self, document: Document, complete_event: Any) -&gt; Generator[Completion, None, None]:\n    \"\"\"Generate completions as a generator for prompt_toolkit.\"\"\"\n    text = document.text_before_cursor\n    line = document.text\n    cursor_position = document.cursor_position_col\n\n    # Tokenize using shlex\n    for quote in (\"\", '\"', \"'\"):\n        # Handle incomplete quoting\n        try:\n            tokens = shlex.split(text + quote, comments=False, posix=False)\n        except ValueError:\n            continue\n        else:\n            break\n    else:  # pragma: no cover\n        # Revert to whitespace tokenization when shlex fails\n        tokens = text.split()\n\n    # Check if cursor is at end of text with trailing space\n    ends_with_space = text.endswith(\" \")\n\n    # If ends with space, we're completing a new token\n    if ends_with_space:\n        tokens.append(\"\")\n\n    # Get the text to complete (last token)\n    text_to_complete = tokens[-1] if tokens else \"\"\n\n    # Calculate start position for completions\n    start_position = -len(text_to_complete)\n\n    # Yield completions directly from _get_completion_texts\n    yield from self._get_completion_texts(\n        text_to_complete, line, cursor_position - len(text_to_complete), cursor_position, tokens, start_position\n    )\n</code></pre>"},{"location":"api/completer/#ptcmd.completer.PrefixCompleter","title":"<code>PrefixCompleter</code>","text":"<p>               Bases: <code>Completer</code></p> <p>Completer that applies a nested completer after a specific prefix.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The string prefix that triggers the nested completer</p> required <code>completer</code> <code>Completer</code> <p>The completer to use for text after the prefix  This completer checks if the input text starts with a specified prefix, and if so, delegates completion to the provided completer for the text after the prefix. The prefix and the subsequent content don't need to be separated by a space.</p> required Source code in <code>src/ptcmd/completer.py</code> <pre><code>class PrefixCompleter(Completer):\n    \"\"\"\n    Completer that applies a nested completer after a specific prefix.\n\n    :param prefix: The string prefix that triggers the nested completer\n    :param completer: The completer to use for text after the prefix\n\n    This completer checks if the input text starts with a specified prefix,\n    and if so, delegates completion to the provided completer for the text after the prefix.\n    The prefix and the subsequent content don't need to be separated by a space.\n    \"\"\"\n\n    def __init__(self, prefix: str, completer: Completer) -&gt; None:\n        \"\"\"\n        Initialize the completer with a prefix and a nested completer.\n\n        :param prefix: The string prefix that triggers the nested completer\n        :type prefix: str\n        :param completer: The completer to use for text after the prefix\n        :type completer: Completer\n        \"\"\"\n        self.prefix = prefix\n        self.completer = completer\n\n    def get_completions(self, document: Document, complete_event: Any) -&gt; Iterable[Completion]:\n        text = document.text_before_cursor.lstrip()\n\n        # Check if the text starts with the prefix\n        if text.startswith(self.prefix):\n            # Create a new document with the text after the prefix\n            prefix_length = len(self.prefix)\n            remaining_text = text[prefix_length:]\n            cursor_position = document.cursor_position - prefix_length\n\n            # Create a new document with the remaining text\n            new_document = Document(remaining_text, cursor_position)\n\n            # Get completions from the completer\n            yield from self.completer.get_completions(new_document, complete_event)\n</code></pre>"},{"location":"api/completer/#ptcmd.completer.PrefixCompleter.__init__","title":"<code>__init__(prefix, completer)</code>","text":"<p>Initialize the completer with a prefix and a nested completer.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The string prefix that triggers the nested completer</p> required <code>completer</code> <code>Completer</code> <p>The completer to use for text after the prefix</p> required Source code in <code>src/ptcmd/completer.py</code> <pre><code>def __init__(self, prefix: str, completer: Completer) -&gt; None:\n    \"\"\"\n    Initialize the completer with a prefix and a nested completer.\n\n    :param prefix: The string prefix that triggers the nested completer\n    :type prefix: str\n    :param completer: The completer to use for text after the prefix\n    :type completer: Completer\n    \"\"\"\n    self.prefix = prefix\n    self.completer = completer\n</code></pre>"},{"location":"api/core/","title":"ptcmd.core","text":""},{"location":"api/core/#ptcmd.core.BaseCmd","title":"<code>BaseCmd</code>","text":"<p>               Bases: <code>object</code></p> <p>Base class for command line interfaces in ptcmd.</p> <p>This class provides the core functionality for building interactive command-line applications with features including: - Command registration and execution - Argument parsing and completion - Rich text output formatting - Command history and shortcuts - Help system integration</p> <p>The BaseCmd class is designed to be subclassed to create custom command-line interfaces. Subclasses can register commands using the @command decorator.</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>class BaseCmd(object, metaclass=ABCMeta):\n    \"\"\"Base class for command line interfaces in ptcmd.\n\n    This class provides the core functionality for building interactive command-line\n    applications with features including:\n    - Command registration and execution\n    - Argument parsing and completion\n    - Rich text output formatting\n    - Command history and shortcuts\n    - Help system integration\n\n    The BaseCmd class is designed to be subclassed to create custom command-line\n    interfaces. Subclasses can register commands using the @command decorator.\n    \"\"\"\n\n    __slots__ = [\n        \"stdin\",\n        \"stdout\",\n        \"raw_stdout\",\n        \"theme\",\n        \"prompt\",\n        \"shortcuts\",\n        \"intro\",\n        \"doc_leader\",\n        \"doc_header\",\n        \"misc_header\",\n        \"undoc_header\",\n        \"nohelp\",\n        \"cmdqueue\",\n        \"session\",\n        \"console\",\n        \"lastcmd\",\n        \"command_info\",\n        \"default_category\",\n        \"complete_style\",\n    ]\n    __commands__: ClassVar[Set[CommandLike]] = set()\n\n    COMMAND_FUNC_PREFIX: ClassVar[str] = \"do_\"\n    HELP_FUNC_PREFIX: ClassVar[str] = \"help_\"\n\n    DEFAULT_PROMPT: ClassVar[Any] = \"([cmd.prompt]Cmd[/cmd.prompt]) \"\n    DEFAULT_THEME: ClassVar[Theme] = THEME\n    DEFAULT_SHORTCUTS: ClassVar[Dict[str, str]] = {}\n    DEFAULT_COMPLETE_STYLE: ClassVar[CompleteStyle] = CompleteStyle.READLINE_LIKE\n    DEFAULT_CATEGORY: ClassVar[str] = \"Uncategorized\"\n\n    def __init__(\n        self,\n        stdin: Optional[TextIO] = None,\n        stdout: Optional[TextIO] = None,\n        *,\n        session: Optional[Union[PromptSession, Callable[[Input, Output], PromptSession]]] = None,\n        console: Optional[Console] = None,\n        theme: Optional[Theme] = None,\n        prompt: Any = None,\n        shortcuts: Optional[Dict[str, str]] = None,\n        intro: Optional[Any] = None,\n        complete_style: Optional[CompleteStyle] = None,\n    ) -&gt; None:\n        \"\"\"Initialize the BaseCmd instance with configuration options.\n\n        :param stdin: Input stream (default: sys.stdin)\n        :type stdin: Optional[TextIO]\n        :param stdout: Output stream (default: sys.stdout)\n        :type stdout: Optional[TextIO]\n        :param session: Prompt session instance or factory (default: creates new session)\n        :type session: Optional[Union[PromptSession, Callable[[Input, Output], PromptSession]]]\n        :param console: Rich console instance (default: creates new console)\n        :type console: Optional[Console]\n        :param theme: Rich theme for styling output (default: DEFAULT_THEME)\n        :type theme: Optional[Theme]\n        :param prompt: Command prompt display (default: DEFAULT_PROMPT)\n        :type prompt: Any\n        :param shortcuts: Command shortcut mappings (default: DEFAULT_SHORTCUTS)\n        :type shortcuts: Optional[Dict[str, str]]\n        :param intro: Introductory message shown at startup\n        :type intro: Optional[Any]\n        :param complete_style: Style for completion menu (default: DEFAULT_COMPLETE_STYLE)\n        :type complete_style: Optional[CompleteStyle]\n        :param doc_leader: Header text for help output (default: \"\")\n        \"\"\"\n        if stdin is not None:\n            self.stdin = stdin\n        else:\n            self.stdin = sys.stdin\n        if stdout is not None:\n            self.raw_stdout = stdout\n        else:\n            self.raw_stdout = sys.stdout\n\n        self.theme = theme or self.DEFAULT_THEME\n        self.prompt = prompt or self.DEFAULT_PROMPT\n        self.shortcuts = shortcuts or self.DEFAULT_SHORTCUTS\n        self.complete_style = complete_style or self.DEFAULT_COMPLETE_STYLE\n        self.intro = intro\n        # If any command has been categorized, then all other commands that haven't been categorized\n        # will display under this section in the help output.\n        self.default_category = self.DEFAULT_CATEGORY\n\n        if self.stdin.isatty():  # pragma: no cover\n            input = create_input(self.stdin)\n            output = create_output(self.raw_stdout)\n            if callable(session):\n                self.session = session(input, output)\n            else:\n                self.session = session or PromptSession(input=input, output=output)\n            self.stdout = cast(TextIO, StdoutProxy(raw=True, sleep_between_writes=0.01))\n        else:\n            self.stdout = self.raw_stdout\n            self.session = session if isinstance(session, PromptSession) else None\n        self.console = console or Console(file=self.stdout, theme=self.theme)\n\n        self.cmdqueue = []\n        self.lastcmd = \"\"\n        self.command_info  = {}\n        for info in map(self._build_command_info, self.__commands__):\n            if info.name in self.command_info:\n                raise ValueError(f\"Duplicate command name: {info.name}\")\n            self.command_info[info.name] = info\n\n    def cmdloop(self, intro: Optional[Any] = None) -&gt; None:\n        \"\"\"Start the command loop for synchronous execution.\n\n        This is the main entry point for running the command processor.\n        It wraps the async cmdloop_async() method in an asyncio.run() call.\n\n        :param intro: Optional introductory message to display at startup\n        :type intro: Optional[Any]\n        \"\"\"\n        return asyncio.run(self.cmdloop_async(intro))\n\n    async def cmdloop_async(self, intro: Optional[Any] = None) -&gt; None:\n        \"\"\"Asynchronous command loop that processes user input.\n\n        :param intro: Optional introductory message to display at startup\n        :type intro: Optional[Any]\n        \"\"\"\n        await _ensure_coroutine(self.preloop())\n        try:\n            if intro is not None:\n                self.intro = intro\n            if self.intro:\n                self.console.print(self.intro)\n            stop = None\n            while not stop:\n                if self.cmdqueue:\n                    line = self.cmdqueue.pop(0)\n                else:\n                    try:\n                        line = await self.input_line()\n                    except KeyboardInterrupt:  # pragma: no cover\n                        continue\n                    except EOFError:\n                        line = \"EOF\"\n                line = await _ensure_coroutine(self.precmd(line))\n                stop = await self.onecmd(line)\n                stop = await _ensure_coroutine(self.postcmd(stop, line))\n        finally:\n            await _ensure_coroutine(self.postloop())\n\n    def precmd(self, line: str) -&gt; str:\n        \"\"\"Hook method executed just before command line interpretation.\n\n        Called after the input prompt is generated and issued, but before\n        the command line is interpreted.\n\n        :param line: The input command line\n        :type line: str\n        :return: The processed command line\n        :rtype: str\n        \"\"\"\n        return line\n\n    def postcmd(self, stop: Any, line: str) -&gt; Any:\n        \"\"\"Hook method executed after command dispatch is finished.\n\n        :param stop: Flag indicating whether to stop command loop\n        :type stop: Any\n        :param line: The input command line that was executed\n        :type line: str\n        :return: Flag indicating whether to stop command loop\n        :rtype: Any\n        \"\"\"\n        return stop\n\n    def preloop(self) -&gt; None:\n        \"\"\"Hook method executed once at the start of command processing.\n\n        Called once when cmdloop() is called, before any commands are processed.\n\n        This is typically used for initialization tasks that need to happen\n        before command processing begins.\n        \"\"\"\n        pass\n\n    def postloop(self) -&gt; None:\n        \"\"\"Hook method executed once at the end of command processing.\n\n        Called once when cmdloop() is about to return, after all commands\n        have been processed.\n\n        This is typically used for cleanup tasks that need to happen\n        after command processing completes.\n        \"\"\"\n        pass\n\n    async def input_line(self) -&gt; str:  # pragma: no cover\n        \"\"\"Get a command line from the user.\n\n        :return: The input line from the user\n        :rtype: str\n        \"\"\"\n        if self.session is None:\n            loop = asyncio.get_running_loop()\n            line = await loop.run_in_executor(None, self.stdin.readline)\n            if not line:\n                raise EOFError\n            return line.rstrip(\"\\r\\n\")\n        prompt = self._render_rich_text(self.prompt)\n        if isinstance(prompt, str):\n            prompt = ANSI(prompt)\n        return await self.session.prompt_async(\n            prompt,\n            completer=self.completer,\n            lexer=PygmentsLexer(BashLexer),\n            complete_in_thread=True,\n            complete_style=self.complete_style,\n        )\n\n    def parseline(self, line: str) -&gt; Union[Tuple[str, List[str], str], Tuple[None, None, str]]:\n        \"\"\"Parse the input line into command name and arguments.\n\n        This method handles:\n        1. Stripping whitespace from the input line\n        2. Processing command shortcuts (e.g., '?' -&gt; 'help')\n        3. Tokenizing the command line into command and arguments\n        4. Preserving the original line for history purposes\n\n        :param line: The input command line to parse\n        :type line: str\n        :return: A tuple containing:\n            - command name (str if valid command, None otherwise)\n            - command arguments (List[str] if args exist, None otherwise)\n            - original line (stripped of leading/trailing whitespace)\n        :rtype: Union[Tuple[str, List[str], str], Tuple[None, None, str]]\n        \"\"\"\n        line = line.strip()\n        if not line:\n            return None, None, line\n        for shortcut, cmd_name in self.shortcuts.items():\n            if line.startswith(shortcut):\n                if cmd_name not in self.command_info:\n                    return None, None, line\n                line = f\"{cmd_name} {line[len(shortcut) :]}\"\n        tokens = shlex.split(line, comments=False, posix=False)\n        return tokens[0], tokens[1:], line\n\n    async def onecmd(self, line: str) -&gt; Optional[bool]:\n        \"\"\"Execute a single command line.\n\n        :param line: The input command line to execute\n        :type line: str\n        :return: Boolean to stop command loop (True) or continue (False/None)\n        :rtype: Optional[bool]\n        \"\"\"\n        cmd, arg, _line = await _ensure_coroutine(self.parseline(line))\n        if not _line:\n            return await _ensure_coroutine(self.emptyline())\n        if not cmd:\n            return await _ensure_coroutine(self.default(_line))\n        if line != \"EOF\":\n            self.lastcmd = line\n\n        info = self.command_info.get(cmd)\n        if info is None or info.disabled:\n            return await _ensure_coroutine(self.default(line))\n        assert arg is not None\n        try:\n            result = await _ensure_coroutine(info.cmd_func(arg))\n        except (Exception, SystemExit):\n            self.pexcept()\n            return\n        except KeyboardInterrupt:  # pragma: no cover\n            return\n        return bool(result) if result is not None else None\n\n    async def emptyline(self) -&gt; Optional[bool]:\n        \"\"\"Handle empty line input.\n\n        Called when an empty line is entered in response to the prompt.\n        By default, repeats the last nonempty command entered.\n\n        :return: Boolean to stop command loop (True) or continue (False/None)\n        :rtype: Optional[bool]\n        \"\"\"\n        if self.lastcmd:\n            return await self.onecmd(self.lastcmd)\n\n    async def default(self, line: str) -&gt; Optional[bool]:\n        \"\"\"Handle unknown commands.\n\n        Called when an unknown command is entered. By default, displays\n        an error message indicating the command is unknown.\n\n        :param line: The unknown command line that was entered\n        :type line: str\n        \"\"\"\n        if line == \"EOF\":\n            return True\n        self.perror(f\"Unknown command: {line}\")\n\n    def get_all_commands(self) -&gt; List[str]:\n        \"\"\"Get a list of all registered commands.\n\n        :return: List of command names\n        :rtype: List[str]\n        \"\"\"\n        return list(self.command_info.keys())\n\n    def get_visible_command_info(self) -&gt; List[CommandInfo]:\n        \"\"\"Get a list of all registered commands that are visible and enabled.\n\n        :return: List of visible command info objects\n        :rtype: List[CommandInfo]\n        \"\"\"\n        return [info for info in self.command_info.values() if not info.hidden and not info.disabled]\n\n    def get_visible_commands(self) -&gt; List[str]:\n        \"\"\"Get a list of commands that are visible and enabled.\n\n        Filters out commands marked as hidden or disabled.\n\n        :return: List of visible command names\n        :rtype: List[str]\n        \"\"\"\n        return [info.name for info in self.get_visible_command_info()]\n\n    @property\n    def visible_prompt(self) -&gt; str:\n        \"\"\"Read-only property to get the visible prompt with any ANSI style escape codes stripped.\n\n        Used by transcript testing to make it easier and more reliable when users are doing things like coloring the\n        prompt using ANSI color codes.\n\n        :return: prompt stripped of any ANSI escape codes\n        :rtype: str\n        \"\"\"\n        return ANSI(self._render_rich_text(self.prompt)).value\n\n    @property\n    def completer(self) -&gt; Completer:\n        cmd_completer_options = {info.name: info.completer for info in self.get_visible_command_info()}\n        shortcut_completers = {\n            shortcut: cmd_completer_options[name] for shortcut, name in self.shortcuts.items() if name in cmd_completer_options\n        }\n        return MultiPrefixCompleter(shortcut_completers, NestedCompleter(cmd_completer_options))\n\n    def poutput(self, *objs: Any, sep: str = \" \", end: str = \"\\n\", markup: Optional[bool] = None) -&gt; None:\n        self.console.print(*objs, sep=sep, end=end, markup=markup)\n\n    def perror(self, *objs: Any, sep: str = \" \", end: str = \"\\n\", markup: Optional[bool] = None) -&gt; None:\n        self.console.print(*objs, sep=sep, end=end, style=\"cmd.error\", markup=markup)\n\n    def psuccess(self, *objs: Any, sep: str = \" \", end: str = \"\\n\", markup: Optional[bool] = None) -&gt; None:\n        self.console.print(*objs, sep=sep, end=end, style=\"cmd.success\", markup=markup)\n\n    def pwarning(self, *objs: Any, sep: str = \" \", end: str = \"\\n\", markup: Optional[bool] = None) -&gt; None:\n        self.console.print(*objs, sep=sep, end=end, style=\"cmd.warning\", markup=markup)\n\n    def pexcept(self, *, show_locals: bool = False) -&gt; None:\n        self.console.print_exception(show_locals=show_locals)\n\n    def _render_rich_text(self, text: Any) -&gt; Any:\n        if not isinstance(text, str) and is_formatted_text(text):\n            return text\n        with self.console.capture() as capture:\n            self.console.print(text, end=\"\")\n        return capture.get()\n\n    def _build_command_info(self, cmd: CommandLike) -&gt; CommandInfo:\n        return build_cmd_info(cmd, self)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return detailed command processor representation.\"\"\"\n        return (\n            f\"&lt;{self.__class__.__name__} commands={len(self.command_info)} \"\n            f\"prompt={self.visible_prompt!r} shortcuts={self.shortcuts}&gt;\"\n        )\n\n    def __init_subclass__(cls, **kwds: Any) -&gt; None:\n        parent_cmd_prefix = [base.COMMAND_FUNC_PREFIX for base in cls.__bases__ if issubclass(base, BaseCmd)]\n        if not parent_cmd_prefix:  # pragma: no cover\n            raise TypeError(\"This class must subclass from BaseCmd or a subclass of BaseCmd\")\n        cmd_prefix = parent_cmd_prefix[0]\n        if not all(p == cmd_prefix for p in parent_cmd_prefix):\n            base_names = ', '.join(base.__name__ for base in cls.__bases__ if issubclass(base, BaseCmd))\n            raise TypeError(\n                f\"All BaseCmd parent classes must have the same COMMAND_FUNC_PREFIX. \"\n                f\"Conflicting prefixes found in bases: {base_names}\"\n            )\n        if cmd_prefix != cls.COMMAND_FUNC_PREFIX and cls.__commands__:\n            if cmd_prefix.startswith(cls.COMMAND_FUNC_PREFIX):\n                raise ValueError(\n                    f\"Cannot override command prefix: parent prefix {cmd_prefix!r} conflicts with \"\n                    f\"subclass prefix {cls.COMMAND_FUNC_PREFIX!r}. The parent prefix must not be \"\n                    \"a prefix of the subclass prefix to avoid command name conflicts.\"\n                )\n            warnings.warn(\n                f\"Command prefix changed from {cmd_prefix!r} to {cls.COMMAND_FUNC_PREFIX!r}. \"\n                \"Existing commands cleared to prevent potential conflicts. Redefine commands \"\n                \"using the new prefix.\",\n                RuntimeWarning,\n                stacklevel=3\n            )\n            cls.__commands__ = set()\n        else:\n            cls.__commands__ = set()\n            for base in cls.__bases__:\n                if issubclass(base, BaseCmd):\n                    cls.__commands__.update(base.__commands__)\n        for name in dir(cls):\n            if not name.startswith(cls.COMMAND_FUNC_PREFIX):\n                continue\n            cls.__commands__.add(getattr(cls, name))\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.visible_prompt","title":"<code>visible_prompt</code>  <code>property</code>","text":"<p>Read-only property to get the visible prompt with any ANSI style escape codes stripped.</p> <p>Used by transcript testing to make it easier and more reliable when users are doing things like coloring the prompt using ANSI color codes.</p> <p>Returns:</p> Type Description <code>str</code> <p>prompt stripped of any ANSI escape codes</p>"},{"location":"api/core/#ptcmd.core.BaseCmd.__init__","title":"<code>__init__(stdin=None, stdout=None, *, session=None, console=None, theme=None, prompt=None, shortcuts=None, intro=None, complete_style=None)</code>","text":"<p>Initialize the BaseCmd instance with configuration options.</p> <p>Parameters:</p> Name Type Description Default <code>stdin</code> <code>Optional[TextIO]</code> <p>Input stream (default: sys.stdin)</p> <code>None</code> <code>stdout</code> <code>Optional[TextIO]</code> <p>Output stream (default: sys.stdout)</p> <code>None</code> <code>session</code> <code>Optional[Union[PromptSession, Callable[[Input, Output], PromptSession]]]</code> <p>Prompt session instance or factory (default: creates new session)</p> <code>None</code> <code>console</code> <code>Optional[Console]</code> <p>Rich console instance (default: creates new console)</p> <code>None</code> <code>theme</code> <code>Optional[Theme]</code> <p>Rich theme for styling output (default: DEFAULT_THEME)</p> <code>None</code> <code>prompt</code> <code>Any</code> <p>Command prompt display (default: DEFAULT_PROMPT)</p> <code>None</code> <code>shortcuts</code> <code>Optional[Dict[str, str]]</code> <p>Command shortcut mappings (default: DEFAULT_SHORTCUTS)</p> <code>None</code> <code>intro</code> <code>Optional[Any]</code> <p>Introductory message shown at startup</p> <code>None</code> <code>complete_style</code> <code>Optional[CompleteStyle]</code> <p>Style for completion menu (default: DEFAULT_COMPLETE_STYLE)</p> <code>None</code> <code>doc_leader</code> <p>Header text for help output (default: \"\")</p> required Source code in <code>src/ptcmd/core.py</code> <pre><code>def __init__(\n    self,\n    stdin: Optional[TextIO] = None,\n    stdout: Optional[TextIO] = None,\n    *,\n    session: Optional[Union[PromptSession, Callable[[Input, Output], PromptSession]]] = None,\n    console: Optional[Console] = None,\n    theme: Optional[Theme] = None,\n    prompt: Any = None,\n    shortcuts: Optional[Dict[str, str]] = None,\n    intro: Optional[Any] = None,\n    complete_style: Optional[CompleteStyle] = None,\n) -&gt; None:\n    \"\"\"Initialize the BaseCmd instance with configuration options.\n\n    :param stdin: Input stream (default: sys.stdin)\n    :type stdin: Optional[TextIO]\n    :param stdout: Output stream (default: sys.stdout)\n    :type stdout: Optional[TextIO]\n    :param session: Prompt session instance or factory (default: creates new session)\n    :type session: Optional[Union[PromptSession, Callable[[Input, Output], PromptSession]]]\n    :param console: Rich console instance (default: creates new console)\n    :type console: Optional[Console]\n    :param theme: Rich theme for styling output (default: DEFAULT_THEME)\n    :type theme: Optional[Theme]\n    :param prompt: Command prompt display (default: DEFAULT_PROMPT)\n    :type prompt: Any\n    :param shortcuts: Command shortcut mappings (default: DEFAULT_SHORTCUTS)\n    :type shortcuts: Optional[Dict[str, str]]\n    :param intro: Introductory message shown at startup\n    :type intro: Optional[Any]\n    :param complete_style: Style for completion menu (default: DEFAULT_COMPLETE_STYLE)\n    :type complete_style: Optional[CompleteStyle]\n    :param doc_leader: Header text for help output (default: \"\")\n    \"\"\"\n    if stdin is not None:\n        self.stdin = stdin\n    else:\n        self.stdin = sys.stdin\n    if stdout is not None:\n        self.raw_stdout = stdout\n    else:\n        self.raw_stdout = sys.stdout\n\n    self.theme = theme or self.DEFAULT_THEME\n    self.prompt = prompt or self.DEFAULT_PROMPT\n    self.shortcuts = shortcuts or self.DEFAULT_SHORTCUTS\n    self.complete_style = complete_style or self.DEFAULT_COMPLETE_STYLE\n    self.intro = intro\n    # If any command has been categorized, then all other commands that haven't been categorized\n    # will display under this section in the help output.\n    self.default_category = self.DEFAULT_CATEGORY\n\n    if self.stdin.isatty():  # pragma: no cover\n        input = create_input(self.stdin)\n        output = create_output(self.raw_stdout)\n        if callable(session):\n            self.session = session(input, output)\n        else:\n            self.session = session or PromptSession(input=input, output=output)\n        self.stdout = cast(TextIO, StdoutProxy(raw=True, sleep_between_writes=0.01))\n    else:\n        self.stdout = self.raw_stdout\n        self.session = session if isinstance(session, PromptSession) else None\n    self.console = console or Console(file=self.stdout, theme=self.theme)\n\n    self.cmdqueue = []\n    self.lastcmd = \"\"\n    self.command_info  = {}\n    for info in map(self._build_command_info, self.__commands__):\n        if info.name in self.command_info:\n            raise ValueError(f\"Duplicate command name: {info.name}\")\n        self.command_info[info.name] = info\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.__repr__","title":"<code>__repr__()</code>","text":"<p>Return detailed command processor representation.</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return detailed command processor representation.\"\"\"\n    return (\n        f\"&lt;{self.__class__.__name__} commands={len(self.command_info)} \"\n        f\"prompt={self.visible_prompt!r} shortcuts={self.shortcuts}&gt;\"\n    )\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.cmdloop","title":"<code>cmdloop(intro=None)</code>","text":"<p>Start the command loop for synchronous execution.</p> <p>This is the main entry point for running the command processor. It wraps the async cmdloop_async() method in an asyncio.run() call.</p> <p>Parameters:</p> Name Type Description Default <code>intro</code> <code>Optional[Any]</code> <p>Optional introductory message to display at startup</p> <code>None</code> Source code in <code>src/ptcmd/core.py</code> <pre><code>def cmdloop(self, intro: Optional[Any] = None) -&gt; None:\n    \"\"\"Start the command loop for synchronous execution.\n\n    This is the main entry point for running the command processor.\n    It wraps the async cmdloop_async() method in an asyncio.run() call.\n\n    :param intro: Optional introductory message to display at startup\n    :type intro: Optional[Any]\n    \"\"\"\n    return asyncio.run(self.cmdloop_async(intro))\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.cmdloop_async","title":"<code>cmdloop_async(intro=None)</code>  <code>async</code>","text":"<p>Asynchronous command loop that processes user input.</p> <p>Parameters:</p> Name Type Description Default <code>intro</code> <code>Optional[Any]</code> <p>Optional introductory message to display at startup</p> <code>None</code> Source code in <code>src/ptcmd/core.py</code> <pre><code>async def cmdloop_async(self, intro: Optional[Any] = None) -&gt; None:\n    \"\"\"Asynchronous command loop that processes user input.\n\n    :param intro: Optional introductory message to display at startup\n    :type intro: Optional[Any]\n    \"\"\"\n    await _ensure_coroutine(self.preloop())\n    try:\n        if intro is not None:\n            self.intro = intro\n        if self.intro:\n            self.console.print(self.intro)\n        stop = None\n        while not stop:\n            if self.cmdqueue:\n                line = self.cmdqueue.pop(0)\n            else:\n                try:\n                    line = await self.input_line()\n                except KeyboardInterrupt:  # pragma: no cover\n                    continue\n                except EOFError:\n                    line = \"EOF\"\n            line = await _ensure_coroutine(self.precmd(line))\n            stop = await self.onecmd(line)\n            stop = await _ensure_coroutine(self.postcmd(stop, line))\n    finally:\n        await _ensure_coroutine(self.postloop())\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.default","title":"<code>default(line)</code>  <code>async</code>","text":"<p>Handle unknown commands.</p> <p>Called when an unknown command is entered. By default, displays an error message indicating the command is unknown.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The unknown command line that was entered</p> required Source code in <code>src/ptcmd/core.py</code> <pre><code>async def default(self, line: str) -&gt; Optional[bool]:\n    \"\"\"Handle unknown commands.\n\n    Called when an unknown command is entered. By default, displays\n    an error message indicating the command is unknown.\n\n    :param line: The unknown command line that was entered\n    :type line: str\n    \"\"\"\n    if line == \"EOF\":\n        return True\n    self.perror(f\"Unknown command: {line}\")\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.emptyline","title":"<code>emptyline()</code>  <code>async</code>","text":"<p>Handle empty line input.</p> <p>Called when an empty line is entered in response to the prompt. By default, repeats the last nonempty command entered.</p> <p>Returns:</p> Type Description <code>Optional[bool]</code> <p>Boolean to stop command loop (True) or continue (False/None)</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>async def emptyline(self) -&gt; Optional[bool]:\n    \"\"\"Handle empty line input.\n\n    Called when an empty line is entered in response to the prompt.\n    By default, repeats the last nonempty command entered.\n\n    :return: Boolean to stop command loop (True) or continue (False/None)\n    :rtype: Optional[bool]\n    \"\"\"\n    if self.lastcmd:\n        return await self.onecmd(self.lastcmd)\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.get_all_commands","title":"<code>get_all_commands()</code>","text":"<p>Get a list of all registered commands.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of command names</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>def get_all_commands(self) -&gt; List[str]:\n    \"\"\"Get a list of all registered commands.\n\n    :return: List of command names\n    :rtype: List[str]\n    \"\"\"\n    return list(self.command_info.keys())\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.get_visible_command_info","title":"<code>get_visible_command_info()</code>","text":"<p>Get a list of all registered commands that are visible and enabled.</p> <p>Returns:</p> Type Description <code>List[CommandInfo]</code> <p>List of visible command info objects</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>def get_visible_command_info(self) -&gt; List[CommandInfo]:\n    \"\"\"Get a list of all registered commands that are visible and enabled.\n\n    :return: List of visible command info objects\n    :rtype: List[CommandInfo]\n    \"\"\"\n    return [info for info in self.command_info.values() if not info.hidden and not info.disabled]\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.get_visible_commands","title":"<code>get_visible_commands()</code>","text":"<p>Get a list of commands that are visible and enabled.</p> <p>Filters out commands marked as hidden or disabled.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of visible command names</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>def get_visible_commands(self) -&gt; List[str]:\n    \"\"\"Get a list of commands that are visible and enabled.\n\n    Filters out commands marked as hidden or disabled.\n\n    :return: List of visible command names\n    :rtype: List[str]\n    \"\"\"\n    return [info.name for info in self.get_visible_command_info()]\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.input_line","title":"<code>input_line()</code>  <code>async</code>","text":"<p>Get a command line from the user.</p> <p>Returns:</p> Type Description <code>str</code> <p>The input line from the user</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>async def input_line(self) -&gt; str:  # pragma: no cover\n    \"\"\"Get a command line from the user.\n\n    :return: The input line from the user\n    :rtype: str\n    \"\"\"\n    if self.session is None:\n        loop = asyncio.get_running_loop()\n        line = await loop.run_in_executor(None, self.stdin.readline)\n        if not line:\n            raise EOFError\n        return line.rstrip(\"\\r\\n\")\n    prompt = self._render_rich_text(self.prompt)\n    if isinstance(prompt, str):\n        prompt = ANSI(prompt)\n    return await self.session.prompt_async(\n        prompt,\n        completer=self.completer,\n        lexer=PygmentsLexer(BashLexer),\n        complete_in_thread=True,\n        complete_style=self.complete_style,\n    )\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.onecmd","title":"<code>onecmd(line)</code>  <code>async</code>","text":"<p>Execute a single command line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The input command line to execute</p> required <p>Returns:</p> Type Description <code>Optional[bool]</code> <p>Boolean to stop command loop (True) or continue (False/None)</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>async def onecmd(self, line: str) -&gt; Optional[bool]:\n    \"\"\"Execute a single command line.\n\n    :param line: The input command line to execute\n    :type line: str\n    :return: Boolean to stop command loop (True) or continue (False/None)\n    :rtype: Optional[bool]\n    \"\"\"\n    cmd, arg, _line = await _ensure_coroutine(self.parseline(line))\n    if not _line:\n        return await _ensure_coroutine(self.emptyline())\n    if not cmd:\n        return await _ensure_coroutine(self.default(_line))\n    if line != \"EOF\":\n        self.lastcmd = line\n\n    info = self.command_info.get(cmd)\n    if info is None or info.disabled:\n        return await _ensure_coroutine(self.default(line))\n    assert arg is not None\n    try:\n        result = await _ensure_coroutine(info.cmd_func(arg))\n    except (Exception, SystemExit):\n        self.pexcept()\n        return\n    except KeyboardInterrupt:  # pragma: no cover\n        return\n    return bool(result) if result is not None else None\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.parseline","title":"<code>parseline(line)</code>","text":"<p>Parse the input line into command name and arguments.</p> <p>This method handles: 1. Stripping whitespace from the input line 2. Processing command shortcuts (e.g., '?' -&gt; 'help') 3. Tokenizing the command line into command and arguments 4. Preserving the original line for history purposes</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The input command line to parse</p> required <p>Returns:</p> Type Description <code>Union[Tuple[str, List[str], str], Tuple[None, None, str]]</code> <p>A tuple containing: - command name (str if valid command, None otherwise) - command arguments (List[str] if args exist, None otherwise) - original line (stripped of leading/trailing whitespace)</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>def parseline(self, line: str) -&gt; Union[Tuple[str, List[str], str], Tuple[None, None, str]]:\n    \"\"\"Parse the input line into command name and arguments.\n\n    This method handles:\n    1. Stripping whitespace from the input line\n    2. Processing command shortcuts (e.g., '?' -&gt; 'help')\n    3. Tokenizing the command line into command and arguments\n    4. Preserving the original line for history purposes\n\n    :param line: The input command line to parse\n    :type line: str\n    :return: A tuple containing:\n        - command name (str if valid command, None otherwise)\n        - command arguments (List[str] if args exist, None otherwise)\n        - original line (stripped of leading/trailing whitespace)\n    :rtype: Union[Tuple[str, List[str], str], Tuple[None, None, str]]\n    \"\"\"\n    line = line.strip()\n    if not line:\n        return None, None, line\n    for shortcut, cmd_name in self.shortcuts.items():\n        if line.startswith(shortcut):\n            if cmd_name not in self.command_info:\n                return None, None, line\n            line = f\"{cmd_name} {line[len(shortcut) :]}\"\n    tokens = shlex.split(line, comments=False, posix=False)\n    return tokens[0], tokens[1:], line\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.postcmd","title":"<code>postcmd(stop, line)</code>","text":"<p>Hook method executed after command dispatch is finished.</p> <p>Parameters:</p> Name Type Description Default <code>stop</code> <code>Any</code> <p>Flag indicating whether to stop command loop</p> required <code>line</code> <code>str</code> <p>The input command line that was executed</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Flag indicating whether to stop command loop</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>def postcmd(self, stop: Any, line: str) -&gt; Any:\n    \"\"\"Hook method executed after command dispatch is finished.\n\n    :param stop: Flag indicating whether to stop command loop\n    :type stop: Any\n    :param line: The input command line that was executed\n    :type line: str\n    :return: Flag indicating whether to stop command loop\n    :rtype: Any\n    \"\"\"\n    return stop\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.postloop","title":"<code>postloop()</code>","text":"<p>Hook method executed once at the end of command processing.</p> <p>Called once when cmdloop() is about to return, after all commands have been processed.</p> <p>This is typically used for cleanup tasks that need to happen after command processing completes.</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>def postloop(self) -&gt; None:\n    \"\"\"Hook method executed once at the end of command processing.\n\n    Called once when cmdloop() is about to return, after all commands\n    have been processed.\n\n    This is typically used for cleanup tasks that need to happen\n    after command processing completes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.precmd","title":"<code>precmd(line)</code>","text":"<p>Hook method executed just before command line interpretation.</p> <p>Called after the input prompt is generated and issued, but before the command line is interpreted.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The input command line</p> required <p>Returns:</p> Type Description <code>str</code> <p>The processed command line</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>def precmd(self, line: str) -&gt; str:\n    \"\"\"Hook method executed just before command line interpretation.\n\n    Called after the input prompt is generated and issued, but before\n    the command line is interpreted.\n\n    :param line: The input command line\n    :type line: str\n    :return: The processed command line\n    :rtype: str\n    \"\"\"\n    return line\n</code></pre>"},{"location":"api/core/#ptcmd.core.BaseCmd.preloop","title":"<code>preloop()</code>","text":"<p>Hook method executed once at the start of command processing.</p> <p>Called once when cmdloop() is called, before any commands are processed.</p> <p>This is typically used for initialization tasks that need to happen before command processing begins.</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>def preloop(self) -&gt; None:\n    \"\"\"Hook method executed once at the start of command processing.\n\n    Called once when cmdloop() is called, before any commands are processed.\n\n    This is typically used for initialization tasks that need to happen\n    before command processing begins.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/#ptcmd.core.Cmd","title":"<code>Cmd</code>","text":"<p>               Bases: <code>BaseCmd</code></p> <p>Enhanced command line interface with built-in commands.</p> <p>This class extends BaseCmd with additional functionality including: - Built-in help system - Command shortcuts - Shell command execution - Script running capabilities</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>class Cmd(BaseCmd):\n    \"\"\"Enhanced command line interface with built-in commands.\n\n    This class extends BaseCmd with additional functionality including:\n    - Built-in help system\n    - Command shortcuts\n    - Shell command execution\n    - Script running capabilities\n    \"\"\"\n    __slots__ = []\n\n    DEFAULT_SHORTCUTS: ClassVar[Dict[str, str]] = {\"?\": \"help\", \"!\": \"shell\", \"@\": \"run_script\"}\n\n    def __init__(\n        self,\n        stdin: Optional[TextIO] = None,\n        stdout: Optional[TextIO] = None,\n        *,\n        session: Optional[Union[PromptSession, Callable[[Input, Output], PromptSession]]] = None,\n        console: Optional[Console] = None,\n        theme: Optional[Theme] = None,\n        prompt: Any = None,\n        shortcuts: Optional[Dict[str, str]] = None,\n        intro: Optional[Any] = None,\n        complete_style: Optional[CompleteStyle] = None,\n        doc_leader: str = \"\",\n        doc_header: str = \"Documented commands (type help &lt;topic&gt;):\",\n        misc_header: str = \"Miscellaneous help topics:\",\n        undoc_header: str = \"Undocumented commands:\",\n        nohelp: str = \"No help on %s\",\n    ) -&gt; None:\n        \"\"\"Initialize the Cmd instance with extended configuration options.\n\n        :param stdin: Input stream (default: sys.stdin)\n        :type stdin: Optional[TextIO]\n        :param stdout: Output stream (default: sys.stdout)\n        :type stdout: Optional[TextIO]\n        :param session: Prompt session instance or factory (default: creates new session)\n        :type session: Optional[Union[PromptSession, Callable[[Input, Output], PromptSession]]]\n        :param console: Rich console instance (default: creates new console)\n        :type console: Optional[Console]\n        :param theme: Rich theme for styling output (default: None)\n        :type theme: Optional[Theme]\n        :param prompt: Command prompt display (default: None)\n        :type prompt: Any\n        :param shortcuts: Command shortcut mappings (default: None)\n        :type shortcuts: Optional[Dict[str, str]]\n        :param intro: Introductory message shown at startup (default: None)\n        :type intro: Optional[Any]\n        :param complete_style: Style for completion menu (default: CompleteStyle.READLINE_LIKE)\n        :type complete_style: CompleteStyle\n        :param doc_leader: Header text for help output (default: \"\")\n        :type doc_leader: str\n        :param doc_header: Header for documented commands section (default: \"Documented commands...\")\n        :type doc_header: str\n        :param misc_header: Header for miscellaneous help topics (default: \"Miscellaneous help...\")\n        :type misc_header: str\n        :param undoc_header: Header for undocumented commands (default: \"Undocumented commands:\")\n        :type undoc_header: str\n        :param nohelp: Message shown when no help is available (default: \"No help on %s\")\n        :type nohelp: str\n        \"\"\"\n        super().__init__(\n            stdin=stdin,\n            stdout=stdout,\n            session=session,\n            console=console,\n            theme=theme,\n            prompt=prompt,\n            shortcuts=shortcuts,\n            intro=intro,\n            complete_style=complete_style,\n        )\n        self.doc_leader = doc_leader\n        self.doc_header = doc_header\n        self.misc_header = misc_header\n        self.undoc_header = undoc_header\n        self.nohelp = nohelp\n\n    @auto_argument(help_category=\"ptcmd.builtin\")\n    def do_help(\n        self,\n        topic: Arg[Optional[str], {\"action\": _TopicAction, \"help\": \"Command or topic for help\"}] = None,  # noqa: F821,F722,B002\n        *,\n        verbose: Arg[bool, \"-v\", \"--verbose\", {\"help\": \"Show more detailed help\"}] = False  # noqa: F821,F722,B002\n    ) -&gt; None:\n        \"\"\"List available commands or provide detailed help for a specific command\"\"\"\n        if not topic:\n            return self._help_menu(verbose)\n        help_topics = self._help_topics()\n\n        if topic in help_topics and topic not in self.command_info:\n            return self.poutput(self._format_help_menu(topic, help_topics[topic], verbose=verbose))\n        elif topic not in self.command_info:\n            return self.perror(f\"Unknown command: {topic}\")\n        return self.poutput(Text(self._format_help_text(self.command_info[topic], verbose)))\n\n    def _help_menu(self, verbose: bool = False) -&gt; None:\n        \"\"\"Display the help menu showing available commands and help topics.\n\n        Organizes commands by category if available, otherwise falls back to\n        standard documented/undocumented grouping.\n\n        :param verbose: If True, show more detailed help (not currently used)\n        :type verbose: bool\n        \"\"\"\n        cmds_cats = self._help_topics()\n        cmds_undoc = [\n            info\n            for info in self.get_visible_command_info()\n            if info.help_func is None and info.argparser is None and not info.category and not info.cmd_func.__doc__\n        ]\n        if self.doc_leader:\n            self.poutput(self.doc_leader)\n        if not cmds_cats:\n            # No categories found, fall back to standard behavior\n            self.poutput(\n                self._format_help_menu(\n                    self.doc_header,\n                    self.get_visible_command_info(),\n                    verbose=verbose,\n                    style=\"cmd.help.doc\",\n                )\n            )\n        else:\n            # Categories found, Organize all commands by category\n            cmds_doc = [info for info in self.get_visible_command_info() if not info.category and info not in cmds_undoc]\n\n            # Create a list of renderable objects for each category\n            category_contents = []\n            for category in sorted(cmds_cats.keys()):\n                category_contents.append(Text(category, style=\"bold\"))\n                category_contents.append(self._get_help_content(category, cmds_cats[category], verbose=verbose))\n                category_contents.append(Text(\"\"))  # Add spacing between categories\n\n            # # Add uncategorized commands if they exist\n            # if cmds_doc:\n            #     category_contents.append(Text(self.default_category, style=\"bold\"))\n            #     category_contents.append(self._get_help_content(self.default_category, cmds_doc, verbose=verbose))\n            #     category_contents.append(Text(\"\"))  # Add spacing\n\n            self.poutput(Panel(\n                Columns(category_contents[:-1]),  # Remove the last empty text for better spacing\n                title=self.doc_header,\n                title_align=\"left\",\n                style=\"cmd.help.doc\",\n            ))\n            if cmds_doc:\n                self.poutput(self._format_help_menu(self.default_category, cmds_doc, verbose=verbose, style=\"cmd.help.doc\"))\n            self.poutput(\n                Panel(\n                    Columns([f\"[cmd.help.name]{name}[/cmd.help.name]\" for name in cmds_cats]),\n                    title=self.misc_header,\n                    title_align=\"left\",\n                    style=\"cmd.help.misc\",\n                )\n            )\n\n        if cmds_undoc:\n            self.poutput(self._format_help_menu(self.undoc_header, cmds_undoc, verbose=verbose, style=\"cmd.help.undoc\"))\n\n    def _format_help_menu(\n        self, title: str, cmds_info: List[CommandInfo], *, verbose: bool = False, style: Union[str, Style, None] = None\n    ) -&gt; Panel:\n        cmds_info.sort(key=lambda info: info.name)\n        return Panel(\n            Columns(\n                [\n                    Text.from_markup(f\"[cmd.help.name]{info.name}[/cmd.help.name] - \").append_text(\n                        Text.from_ansi(self._format_help_text(info))\n                    )\n                    if verbose\n                    else f\"[cmd.help.name]{info.name}[/cmd.help.name]\"\n                    for info in cmds_info\n                ]\n            ),\n            title=title,\n            title_align=\"left\",\n            style=style or \"cmd.help.misc\",\n        )\n\n    def _format_help_text(self, cmd_info: CommandInfo, verbose: bool = False) -&gt; str:\n        \"\"\"Format the help text for a command.\n\n        :param cmd_info: The command info object\n        :type cmd_info: CommandInfo\n        :return: The formatted help text\n        :rtype: str\n        \"\"\"\n        if cmd_info.help_func is not None:\n            return cmd_info.help_func(verbose)\n        if cmd_info.argparser is not None:\n            if verbose:\n                return cmd_info.argparser.format_help().rstrip()\n            elif cmd_info.argparser.description is not None:\n                return cmd_info.argparser.description.rstrip()\n            else:\n                return cmd_info.argparser.format_usage().rstrip()\n        if cmd_info.cmd_func.__doc__ is not None:\n            return pydoc.getdoc(cmd_info.cmd_func)\n        else:\n            return self.nohelp % (cmd_info.name,)\n\n    def _get_help_content(self, title: str, cmds_info: List[CommandInfo], *, verbose: bool = False) -&gt; Columns:\n        \"\"\"Return help content without Panel wrapper.\n\n        :param title: The title for the help section\n        :type title: str\n        :param cmds_info: List of command info objects\n        :type cmds_info: List[CommandInfo]\n        :param verbose: If True, show more detailed help\n        :type verbose: bool\n        :return: Columns containing the help content\n        :rtype: Columns\n        \"\"\"\n        cmds_info.sort(key=lambda info: info.name)\n        return Columns(\n            [\n                Text.from_markup(f\"[cmd.help.name]{info.name}[/cmd.help.name] - \").append_text(\n                    Text.from_ansi(self._format_help_text(info))\n                )\n                if verbose\n                else f\"[cmd.help.name]{info.name}[/cmd.help.name]\"\n                for info in cmds_info\n            ]\n        )\n\n    def _help_topics(self) -&gt; Dict[str, List[CommandInfo]]:\n        cmds_cats = defaultdict(list)\n        for info in self.get_visible_command_info():\n            if info.category is not None:\n                cmds_cats[info.category].append(info)\n        return cmds_cats\n\n    @set_info(\"exit\", help_category=\"ptcmd.builtin\")\n    def do_exit(self, argv: List[str]) -&gt; bool:\n        \"\"\"Exit the command loop\"\"\"\n        return True\n\n    @set_info(\"shell\", help_category=\"ptcmd.builtin\", hidden=True)\n    async def do_shell(self, argv: List[str]) -&gt; None:\n        \"\"\"Run a shell command\"\"\"\n        cmd = \" \".join(argv)\n        loop = asyncio.get_running_loop()\n        with suppress(NotImplementedError):\n            loop.add_signal_handler(signal.SIGINT, lambda: None)\n        try:\n            ret = await asyncio.create_subprocess_shell(\n                cmd,\n                stdin=None,\n                stdout=self.stdout,\n                stderr=self.stdout,\n                # start_new_session=True\n            )\n            returncode = await ret.wait()\n        finally:\n            with suppress(NotImplementedError):\n                loop.remove_signal_handler(signal.SIGINT)\n        if returncode != 0:\n            self.perror(f\"Command failed with exit code {ret.returncode}\")\n</code></pre>"},{"location":"api/core/#ptcmd.core.Cmd.__init__","title":"<code>__init__(stdin=None, stdout=None, *, session=None, console=None, theme=None, prompt=None, shortcuts=None, intro=None, complete_style=None, doc_leader='', doc_header='Documented commands (type help &lt;topic&gt;):', misc_header='Miscellaneous help topics:', undoc_header='Undocumented commands:', nohelp='No help on %s')</code>","text":"<p>Initialize the Cmd instance with extended configuration options.</p> <p>Parameters:</p> Name Type Description Default <code>stdin</code> <code>Optional[TextIO]</code> <p>Input stream (default: sys.stdin)</p> <code>None</code> <code>stdout</code> <code>Optional[TextIO]</code> <p>Output stream (default: sys.stdout)</p> <code>None</code> <code>session</code> <code>Optional[Union[PromptSession, Callable[[Input, Output], PromptSession]]]</code> <p>Prompt session instance or factory (default: creates new session)</p> <code>None</code> <code>console</code> <code>Optional[Console]</code> <p>Rich console instance (default: creates new console)</p> <code>None</code> <code>theme</code> <code>Optional[Theme]</code> <p>Rich theme for styling output (default: None)</p> <code>None</code> <code>prompt</code> <code>Any</code> <p>Command prompt display (default: None)</p> <code>None</code> <code>shortcuts</code> <code>Optional[Dict[str, str]]</code> <p>Command shortcut mappings (default: None)</p> <code>None</code> <code>intro</code> <code>Optional[Any]</code> <p>Introductory message shown at startup (default: None)</p> <code>None</code> <code>complete_style</code> <code>Optional[CompleteStyle]</code> <p>Style for completion menu (default: CompleteStyle.READLINE_LIKE)</p> <code>None</code> <code>doc_leader</code> <code>str</code> <p>Header text for help output (default: \"\")</p> <code>''</code> <code>doc_header</code> <code>str</code> <p>Header for documented commands section (default: \"Documented commands...\")</p> <code>'Documented commands (type help &lt;topic&gt;):'</code> <code>misc_header</code> <code>str</code> <p>Header for miscellaneous help topics (default: \"Miscellaneous help...\")</p> <code>'Miscellaneous help topics:'</code> <code>undoc_header</code> <code>str</code> <p>Header for undocumented commands (default: \"Undocumented commands:\")</p> <code>'Undocumented commands:'</code> <code>nohelp</code> <code>str</code> <p>Message shown when no help is available (default: \"No help on %s\")</p> <code>'No help on %s'</code> Source code in <code>src/ptcmd/core.py</code> <pre><code>def __init__(\n    self,\n    stdin: Optional[TextIO] = None,\n    stdout: Optional[TextIO] = None,\n    *,\n    session: Optional[Union[PromptSession, Callable[[Input, Output], PromptSession]]] = None,\n    console: Optional[Console] = None,\n    theme: Optional[Theme] = None,\n    prompt: Any = None,\n    shortcuts: Optional[Dict[str, str]] = None,\n    intro: Optional[Any] = None,\n    complete_style: Optional[CompleteStyle] = None,\n    doc_leader: str = \"\",\n    doc_header: str = \"Documented commands (type help &lt;topic&gt;):\",\n    misc_header: str = \"Miscellaneous help topics:\",\n    undoc_header: str = \"Undocumented commands:\",\n    nohelp: str = \"No help on %s\",\n) -&gt; None:\n    \"\"\"Initialize the Cmd instance with extended configuration options.\n\n    :param stdin: Input stream (default: sys.stdin)\n    :type stdin: Optional[TextIO]\n    :param stdout: Output stream (default: sys.stdout)\n    :type stdout: Optional[TextIO]\n    :param session: Prompt session instance or factory (default: creates new session)\n    :type session: Optional[Union[PromptSession, Callable[[Input, Output], PromptSession]]]\n    :param console: Rich console instance (default: creates new console)\n    :type console: Optional[Console]\n    :param theme: Rich theme for styling output (default: None)\n    :type theme: Optional[Theme]\n    :param prompt: Command prompt display (default: None)\n    :type prompt: Any\n    :param shortcuts: Command shortcut mappings (default: None)\n    :type shortcuts: Optional[Dict[str, str]]\n    :param intro: Introductory message shown at startup (default: None)\n    :type intro: Optional[Any]\n    :param complete_style: Style for completion menu (default: CompleteStyle.READLINE_LIKE)\n    :type complete_style: CompleteStyle\n    :param doc_leader: Header text for help output (default: \"\")\n    :type doc_leader: str\n    :param doc_header: Header for documented commands section (default: \"Documented commands...\")\n    :type doc_header: str\n    :param misc_header: Header for miscellaneous help topics (default: \"Miscellaneous help...\")\n    :type misc_header: str\n    :param undoc_header: Header for undocumented commands (default: \"Undocumented commands:\")\n    :type undoc_header: str\n    :param nohelp: Message shown when no help is available (default: \"No help on %s\")\n    :type nohelp: str\n    \"\"\"\n    super().__init__(\n        stdin=stdin,\n        stdout=stdout,\n        session=session,\n        console=console,\n        theme=theme,\n        prompt=prompt,\n        shortcuts=shortcuts,\n        intro=intro,\n        complete_style=complete_style,\n    )\n    self.doc_leader = doc_leader\n    self.doc_header = doc_header\n    self.misc_header = misc_header\n    self.undoc_header = undoc_header\n    self.nohelp = nohelp\n</code></pre>"},{"location":"api/core/#ptcmd.core.Cmd.do_exit","title":"<code>do_exit(argv)</code>","text":"<p>Exit the command loop</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>@set_info(\"exit\", help_category=\"ptcmd.builtin\")\ndef do_exit(self, argv: List[str]) -&gt; bool:\n    \"\"\"Exit the command loop\"\"\"\n    return True\n</code></pre>"},{"location":"api/core/#ptcmd.core.Cmd.do_help","title":"<code>do_help(topic=None, *, verbose=False)</code>","text":"<p>List available commands or provide detailed help for a specific command</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>@auto_argument(help_category=\"ptcmd.builtin\")\ndef do_help(\n    self,\n    topic: Arg[Optional[str], {\"action\": _TopicAction, \"help\": \"Command or topic for help\"}] = None,  # noqa: F821,F722,B002\n    *,\n    verbose: Arg[bool, \"-v\", \"--verbose\", {\"help\": \"Show more detailed help\"}] = False  # noqa: F821,F722,B002\n) -&gt; None:\n    \"\"\"List available commands or provide detailed help for a specific command\"\"\"\n    if not topic:\n        return self._help_menu(verbose)\n    help_topics = self._help_topics()\n\n    if topic in help_topics and topic not in self.command_info:\n        return self.poutput(self._format_help_menu(topic, help_topics[topic], verbose=verbose))\n    elif topic not in self.command_info:\n        return self.perror(f\"Unknown command: {topic}\")\n    return self.poutput(Text(self._format_help_text(self.command_info[topic], verbose)))\n</code></pre>"},{"location":"api/core/#ptcmd.core.Cmd.do_shell","title":"<code>do_shell(argv)</code>  <code>async</code>","text":"<p>Run a shell command</p> Source code in <code>src/ptcmd/core.py</code> <pre><code>@set_info(\"shell\", help_category=\"ptcmd.builtin\", hidden=True)\nasync def do_shell(self, argv: List[str]) -&gt; None:\n    \"\"\"Run a shell command\"\"\"\n    cmd = \" \".join(argv)\n    loop = asyncio.get_running_loop()\n    with suppress(NotImplementedError):\n        loop.add_signal_handler(signal.SIGINT, lambda: None)\n    try:\n        ret = await asyncio.create_subprocess_shell(\n            cmd,\n            stdin=None,\n            stdout=self.stdout,\n            stderr=self.stdout,\n            # start_new_session=True\n        )\n        returncode = await ret.wait()\n    finally:\n        with suppress(NotImplementedError):\n            loop.remove_signal_handler(signal.SIGINT)\n    if returncode != 0:\n        self.perror(f\"Command failed with exit code {ret.returncode}\")\n</code></pre>"},{"location":"api/info/","title":"ptcmd.info","text":"<p>Command information and metadata handling.</p> <p>This module provides the CommandInfo class and related functionality for storing and retrieving command metadata.</p>"},{"location":"api/info/#ptcmd.info.CommandInfoGetter","title":"<code>CommandInfoGetter</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>src/ptcmd/info.py</code> <pre><code>class CommandInfoGetter(Protocol):\n    def __cmd_info__(self, cmd_ins: \"BaseCmd\", /) -&gt; CommandInfo:\n        \"\"\"Get the command information for this command.\n\n        :param cmd_ins: The instance of the `cmd` class\n        :type cmd_ins: \"BaseCmd\"\n        :return: The command information\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/info/#ptcmd.info.CommandInfoGetter.__cmd_info__","title":"<code>__cmd_info__(cmd_ins)</code>","text":"<p>Get the command information for this command.</p> <p>Parameters:</p> Name Type Description Default <code>cmd_ins</code> <code>BaseCmd</code> <p>The instance of the <code>cmd</code> class</p> required <p>Returns:</p> Type Description <code>CommandInfo</code> <p>The command information</p> Source code in <code>src/ptcmd/info.py</code> <pre><code>def __cmd_info__(self, cmd_ins: \"BaseCmd\", /) -&gt; CommandInfo:\n    \"\"\"Get the command information for this command.\n\n    :param cmd_ins: The instance of the `cmd` class\n    :type cmd_ins: \"BaseCmd\"\n    :return: The command information\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/info/#ptcmd.info.bind_parser","title":"<code>bind_parser(parser, cmd_name, cmd_ins)</code>","text":"<p>Binds an ArgumentParser to a command function.</p> <p>Creates a copy of the parser, sets its prog to the full command path, and binds the command name and command instance to the parser and all its actions. Handles subparsers recursively. Raises ValueError if the parser is already bound.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The ArgumentParser to bind</p> required <code>cmd_name</code> <code>str</code> <p>The name of the command</p> required <code>cmd_ins</code> <code>BaseCmd</code> <p>The instance of the command</p> required <p>Returns:</p> Type Description <code>ArgumentParser</code> <p>The bound ArgumentParser</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parser is already bound</p> Source code in <code>src/ptcmd/info.py</code> <pre><code>def bind_parser(parser: ArgumentParser, cmd_name: str, cmd_ins: \"BaseCmd\") -&gt; ArgumentParser:\n    \"\"\"\n    Binds an ArgumentParser to a command function.\n\n    Creates a copy of the parser, sets its prog to the full command path,\n    and binds the command name and command instance to the parser and all\n    its actions. Handles subparsers recursively. Raises ValueError if\n    the parser is already bound.\n\n    :param parser: The ArgumentParser to bind\n    :type parser: ArgumentParser\n    :param cmd_name: The name of the command\n    :type cmd_name: str\n    :param cmd_ins: The instance of the command\n    :type cmd_ins: BaseCmd\n    :return: The bound ArgumentParser\n    :rtype: ArgumentParser\n    :raises ValueError: If parser is already bound\n    \"\"\"\n    # Check if parser is already bound\n    if hasattr(parser, PARSER_ATTR_CMD):  # pragma: no cover\n        raise ValueError(\"parser is already bound to a command\")\n\n    # Create a shallow copy of the parser\n    new_parser = copy.copy(parser)\n\n    # Build full command path for this parser\n    if ' ' in new_parser.prog:\n        cmds = new_parser.prog.split(' ')\n        cmds[0] = cmd_name\n        new_parser.prog = ' '.join(cmds)\n    else:\n        new_parser.prog = cmd_name\n\n    # Bind command metadata to parser\n    with suppress(AttributeError):\n        setattr(new_parser, PARSER_ATTR_CMD, cmd_ins)\n        setattr(new_parser, PARSER_ATTR_NAME, cmd_name)\n\n    # Set _print_message to use cmd_ins.poutput\n    with suppress(AttributeError):\n        new_parser._print_message = lambda message, file = None: cmd_ins.poutput(Text(message))\n\n    # Process all actions in the parser\n    new_actions = []\n    for action in new_parser._actions:\n        action = copy.copy(action)\n        # Bind command metadata to action\n        with suppress(AttributeError):\n            setattr(action, ACTION_ATTR_CMD, cmd_ins)\n            setattr(action, ACTION_ATTR_NAME, cmd_name)\n\n        # Handle subparsers recursively\n        if isinstance(action, _SubParsersAction):\n            for n, subparser in action.choices.items():\n                # Recursively bind subparsers\n                action.choices[n] = bind_parser(subparser, cmd_name, cmd_ins)\n        new_actions.append(action)\n\n    new_parser._actions = new_actions\n    return new_parser\n</code></pre>"},{"location":"api/info/#ptcmd.info.get_cmd_ins","title":"<code>get_cmd_ins(obj)</code>","text":"<p>Get the BaseCmd instance from an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[BaseCmd, ArgumentParser, Action]</code> <p>The object to get the BaseCmd instance from</p> required <p>Returns:</p> Type Description <code>Optional[BaseCmd]</code> <p>The BaseCmd instance</p> Source code in <code>src/ptcmd/info.py</code> <pre><code>def get_cmd_ins(obj: Union[\"BaseCmd\", ArgumentParser, Action]) -&gt; Optional[\"BaseCmd\"]:\n    \"\"\"Get the BaseCmd instance from an object.\n\n    :param obj: The object to get the BaseCmd instance from\n    :type obj: Union[BaseCmd, ArgumentParser, Action]\n    :return: The BaseCmd instance\n    :rtype: Optional[BaseCmd]\n    \"\"\"\n    from .core import BaseCmd\n    if isinstance(obj, BaseCmd):  # pragma: no cover\n        return obj\n    elif isinstance(obj, ArgumentParser):\n        return getattr(obj, PARSER_ATTR_CMD, None)\n    elif isinstance(obj, Action):\n        return getattr(obj, ACTION_ATTR_CMD, None)\n</code></pre>"},{"location":"user_guide/","title":"User Guide","text":"<p>The user guide primarily introduces the specific usage instructions of <code>ptcmd</code>, covering some underlying implementation details.</p>"},{"location":"user_guide/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Core Concepts: Introduction to the fundamental building blocks of ptcmd, including the main application structure and essential components</li> <li>Argument Handling: Comprehensive guide to defining and processing command arguments with validation and type conversion</li> <li>Command Implementation: Detailed explanation of command definition, execution flow, and advanced command patterns</li> </ul>"},{"location":"user_guide/argument/","title":"Argument Parsing","text":"<p>The argument parsing system provides functionality to build <code>ArgumentParser</code> from function signatures. This is a relatively independent component that integrates with the command component class <code>Command</code> to enter the <code>ptcmd</code> framework.</p>"},{"location":"user_guide/argument/#basic-example","title":"Basic Example","text":"<p>Using the <code>@auto_argument</code> decorator is the simplest declarative way to handle argument parsing. It automatically analyzes the function's parameter signature and creates the corresponding <code>ArgumentParser</code> instance:</p> <pre><code>from ptcmd import Cmd, auto_argument\n\nclass MyApp(Cmd):\n    @auto_argument\n    def do_hello(self, name: str = \"World\") -&gt; None:\n        \"\"\"Hello World!\"\"\"\n        self.poutput(f\"Hello, {name}!\")\n</code></pre> <p>In the example above, the <code>name</code> parameter is automatically converted to an optional positional argument with a default value of \"World\".</p>"},{"location":"user_guide/argument/#argument-class","title":"Argument Class","text":"<p><code>Argument</code> is the core class of the argument parsing system, used to declaratively define command-line arguments. It encapsulates <code>argparse</code> parameter configurations, providing a more Pythonic interface.</p>"},{"location":"user_guide/argument/#basic-usage","title":"Basic Usage","text":"<p>You can directly instantiate <code>Argument</code> to define parameters:</p> <pre><code>from ptcmd import Argument\n\n# Create a simple string parameter\nfile_arg = Argument(\n    \"--file\", \n    type=str,\n    help=\"Input file path\"\n)\n\n# Create a boolean flag parameter\nverbose_arg = Argument(\n    \"-v\", \"--verbose\",\n    action=\"store_true\",\n    help=\"Enable verbose output\"\n)\n</code></pre>"},{"location":"user_guide/argument/#parameter-configuration","title":"Parameter Configuration","text":"<p><code>Argument</code> supports all standard <code>argparse</code> parameter configurations. Common parameters include:</p> Parameter Description Example <code>action</code> Specifies parameter action <code>action=\"store_true\"</code> <code>nargs</code> Number of parameter values <code>nargs='*'</code> <code>const</code> Constant value used with <code>nargs</code> or <code>action</code> <code>const=\"value\"</code> <code>default</code> Default value <code>default=0</code> <code>type</code> Parameter type conversion function <code>type=int</code> <code>choices</code> Allowed parameter values <code>choices=[\"a\", \"b\"]</code> <code>required</code> Whether parameter is required <code>required=True</code> <code>help</code> Help text <code>help=\"Input file path\"</code> <code>metavar</code> Parameter name displayed in help message <code>metavar=\"FILE\"</code> <code>dest</code> Target attribute name for storing parameter value <code>dest=\"output_file\"</code> <code>version</code> Version number used with <code>action=\"version\"</code> <code>version=\"1.0.0\"</code> <p>For example, defining a parameter that requires multiple input files:</p> <pre><code>files: Arg[\n    list,\n    \"--files\",\n    {\"nargs\": \"*\", \"type\": str, \"help\": \"List of input files\"}\n]\n</code></pre>"},{"location":"user_guide/argument/#using-arg-type-annotations","title":"Using Arg Type Annotations","text":"<p>For more complex parameter definitions, you can use <code>Arg</code> type hints. <code>Arg</code> allows specifying parameter flags, help text, and other attributes:</p> <pre><code>from ptcmd import Cmd, Arg, auto_argument\n\nclass MathApp(Cmd):\n    @auto_argument\n    def do_add(\n        self, \n        x: float, \n        y: float,\n        *,\n        verbose: Arg[bool, \"-v\", \"--verbose\", {\"help\": \"Verbose output\"}] = False\n    ) -&gt; None:\n        \"\"\"Add two numbers\"\"\"\n        result = x + y\n        if verbose:\n            self.poutput(f\"{x} + {y} = {result}\")\n        else:\n            self.poutput(result)\n</code></pre> <p>The syntax for <code>Arg</code> is: <code>Arg[Type, parameter flags..., {parameter attributes}]</code></p> <ul> <li>Type: Data type of the parameter (e.g., <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>)</li> <li>Parameter flags: Command-line flags for the parameter (e.g., <code>\"-v\"</code>, <code>\"--verbose\"</code>)</li> <li>Parameter attributes: A dictionary containing other parameter attributes (e.g., <code>help</code>, <code>choices</code>), or an <code>Argument</code> instance can be used as attributes.</li> </ul> <p>Note</p> <p><code>Arg</code> is essentially a simple conversion for type checkers and is functionally equivalent to the <code>Argument</code> class at runtime. However, <code>Arg</code> is typically recommended only for type annotations.</p>"},{"location":"user_guide/argument/#using-annotated-and-argument-type-annotations","title":"Using Annotated and Argument Type Annotations","text":"<p>If you want to strictly adhere to code style checkers, you can use standard <code>Annotated</code> and <code>Argument</code> to avoid syntax errors with <code>Arg</code>:</p> <pre><code>from typing import Annotated\nfrom ptcmd import Cmd, Argument, auto_argument\n\nclass MathApp(Cmd):\n    @auto_argument\n    def do_add(\n        self, \n        x: float, \n        y: float,\n        *,\n        verbose: Annotated[bool, Argument(\"-v\", \"--verbose\", action=\"store_true\")] = False\n    ) -&gt; None:\n        \"\"\"Add two numbers\"\"\"\n        result = x + y\n        if verbose:\n            self.poutput(f\"{x} + {y} = {result}\")\n        else:\n            self.poutput(result)\n</code></pre> <p>However, parameters defined this way won't benefit from parameter field completion, requiring you to specify all necessary fields in the <code>Argument</code>.</p>"},{"location":"user_guide/argument/#parameter-ignoring","title":"Parameter Ignoring","text":"<p>When certain parameters shouldn't appear in the command-line interface, you can use the <code>IgnoreArg</code> type to mark that the parameter should be ignored:</p> <pre><code>from ptcmd import Cmd, IgnoreArg, auto_argument\n\nclass App(Cmd):\n    @auto_argument\n    def do_process(\n        self,\n        input: str,\n        internal_state: IgnoreArg[dict] = {}\n    ) -&gt; None:\n        \"\"\"Process input data; internal_state is only for internal state management\"\"\"\n        # internal_state will not appear in command-line arguments\n        self.poutput(f\"Processing {input}\")\n</code></pre> <p>In this example, the <code>internal_state</code> parameter will be completely ignored and not added to the command-line parser.</p>"},{"location":"user_guide/argument/#argument-parsing_1","title":"Argument Parsing","text":"<p><code>ptcmd</code> automatically infers parameter behavior based on the parameter's type and position:</p> <ol> <li>Positional arguments: Function positional parameters are converted to command-line positional arguments</li> <li>Optional arguments: Keyword arguments separated by <code>*</code> are converted to optional arguments</li> <li>Boolean parameters: Parameters of type <code>bool</code> are automatically converted to flag arguments (<code>store_true</code> or <code>store_false</code>)</li> <li>Default values: Parameter default values are passed to <code>ArgumentParser</code></li> </ol>"},{"location":"user_guide/argument/#automatic-inference","title":"Automatic Inference","text":"<p>Argument parsing can automatically infer appropriate <code>argparse</code> configurations based on type annotations and parameter characteristics, reducing manual configuration. Below are key automatic inference rules:</p>"},{"location":"user_guide/argument/#boolean-type-automatic-conversion","title":"Boolean Type Automatic Conversion","text":"<p>The system automatically selects <code>store_true</code> or <code>store_false</code> actions based on the default value of boolean parameters:</p> <pre><code># Default value is False -&gt; automatically uses store_true\nverbose: Arg[bool] = False  \n# Generates: parser.add_argument(\"--verbose\", action=\"store_true\")\n\n# Default value is True -&gt; automatically uses store_false\nenabled: Arg[bool] = True   \n# Generates: parser.add_argument(\"--enabled\", action=\"store_false\")\n\n# Can also specify flags explicitly\ndebug: Arg[bool, \"-d\", \"--debug\"] = False\n# Generates: parser.add_argument(\"-d\", \"--debug\", action=\"store_true\")\n</code></pre>"},{"location":"user_guide/argument/#positional-vs-keyword-parameter-handling","title":"Positional vs. Keyword Parameter Handling","text":"<p>The system automatically determines whether parameters are positional or optional based on their position in the function signature:</p> <pre><code>@auto_argument\ndef do_process(\n    self,\n    input_file: str,      # Positional parameter (no default value)\n    output: str = \"out\",  # Positional parameter (with default value)\n    *,\n    verbose: bool = False # Keyword parameter -&gt; optional parameter\n) -&gt; None:\n    pass\n</code></pre> <ul> <li>Positional parameters: Positional parameters in function signatures (without <code>*</code> separator) become command-line positional parameters</li> <li>Optional parameters: Keyword parameters separated by <code>*</code> become command-line optional parameters (must use <code>--</code> prefix)</li> </ul>"},{"location":"user_guide/argument/#literal-type-smart-handling","title":"Literal Type Smart Handling","text":"<p>When parameter type is <code>Literal</code>, the system automatically sets <code>choices</code> and adjusts parameter behavior as needed:</p> <pre><code>from typing import Literal\n\n# Automatically sets choices\nlevel: Literal[\"debug\", \"info\", \"warning\", \"error\"]\n\n# Combined with default value\nlevel: Literal[\"debug\", \"info\", \"warning\", \"error\"] = \"info\"\n# Generates: parser.add_argument(\"--level\", choices=..., default=\"info\")\n\n# Combined with keyword parameter (automatically becomes optional parameter)\ndef do_set(\n    self,\n    *,\n    level: Literal[\"debug\", \"info\"] = \"info\"\n) -&gt; None:\n    pass\n# Generates: parser.add_argument(\"--level\", ...)\n</code></pre> <p>Note that if <code>choices</code> is explicitly specified in <code>Argument</code>, it will override the options automatically derived from <code>Literal</code> type:</p>"},{"location":"user_guide/argument/#default-value-handling","title":"Default Value Handling","text":"<p>Default values directly affect parameter behavior:</p> <pre><code># Positional parameter with default value -&gt; becomes optional positional parameter\ndef do_example(self, file: str = \"default.txt\") -&gt; None:\n    pass\n# Generates: parser.add_argument(\"file\", nargs=\"?\", default=\"default.txt\")\n\n# Keyword parameter with default value -&gt; standard optional parameter\ndef do_example(self, *, count: int = 1) -&gt; None:\n    pass\n# Generates: parser.add_argument(\"--count\", type=int, default=1)\n</code></pre>"},{"location":"user_guide/argument/#handling-unannotated-parameters","title":"Handling Unannotated Parameters","text":"<p>When function parameters are not annotated with <code>Arg</code> or <code>Argument</code>, <code>build_parser</code> provides three handling modes controlled by the <code>unannotated_mode</code> parameter:</p> <ul> <li>strict: Strict mode, raises <code>TypeError</code> when encountering unannotated parameters</li> <li>autoconvert: Automatic conversion mode, attempts to infer parameter configuration based on type annotations</li> <li>ignore: Ignore mode, skips unannotated parameters</li> </ul> <p>The <code>@auto_argument</code> decorator defaults to autoconvert mode. In automatic inference mode, unannotated parameters <code>x: Tp</code> are treated as <code>x: Arg[Tp]</code> to automatically infer parameter information.</p> <pre><code>@auto_argument(unannotated_mode=\"autoconvert\")\ndef do_convert(self, x: int, *, y: str = \"y\") -&gt; None:\n    ...\n</code></pre> <p>In <code>autoconvert</code> mode, the above code is treated as:</p> <pre><code>@auto_argument(unannotated_mode=\"autoconvert\")\ndef do_convert(self, x: Arg[int], *, y: Arg[str] = \"y\") -&gt; None:\n    ...\n</code></pre> <p>After automatic parameter inference, the code is ultimately converted to:</p> <pre><code>@auto_argument(unannotated_mode=\"autoconvert\")\ndef do_convert(self, x: Annotated[int, Argument(\"x\", type=int)], *, y: Annotated[str, Argument(\"-y\", type=str, default=\"y\")] = \"y\") -&gt; None:\n    ...\n</code></pre>"},{"location":"user_guide/argument/#standalone-argument-parsing","title":"Standalone Argument Parsing","text":"<p>The argument parsing system provides a series of standalone functions for independent use of argument parsing functionality. The simplest way is to use the <code>entrypoint</code> decorator:</p> <p>```python linenums=\"1\" from ptcmd.argument import entrypoint</p> <p>@entrypoint def main(     x: int,     *,     y: str = \"y\" ) -&gt; None:     ...</p> <p>if name == \"main\":     main()  # Parse arguments from sys.argv and run</p>"},{"location":"user_guide/command/","title":"Commands","text":"<p>To provide automatic command parameter parsing while maintaining compatibility with <code>cmd</code>-style manual parsing systems, <code>ptcmd</code> employs a multi-level hierarchical command system.</p>"},{"location":"user_guide/command/#command-metadata","title":"Command Metadata","text":"<p>Command metadata is the command information directly used by the <code>BaseCmd</code> and <code>Cmd</code> classes:</p> <pre><code>class CommandInfo(NamedTuple):\n    name: str\n    cmd_func: Callable[[List[str]], Any]\n    help_func: Optional[HelpGetterFunc] = None\n    category: Optional[str] = None\n    completer: Optional[Completer] = None\n    argparser: Optional[ArgumentParser] = None\n    hidden: bool = False\n    disabled: bool = False\n\n    def __cmd_info__(self, cmd_ins: \"BaseCmd\", /) -&gt; \"CommandInfo\":\n        return self\n</code></pre>"},{"location":"user_guide/command/#command-information-collection","title":"Command Information Collection","text":"<p>Since command names, handler functions, and other metadata depend on the <code>Cmd</code> instance's configuration or require direct binding to the instance, command information collection occurs during the final stage of <code>Cmd</code> instance initialization.</p> <p>The command information collection logic works as follows:</p> <pre><code>flowchart TD\n    G[BaseCmd Instantiation] --&gt; H{Iterate through __commands__ set}\n    H --&gt; J[Call build_command_info for each command]\n    J --&gt; K{Command Type Check}\n    K --&gt;|Command Instance| L[Call command's __cmd_info__ method]\n    K --&gt;|Regular Function| M[Retrieve command information from function attributes]\n    L --&gt; N[Generate CommandInfo object]\n    M --&gt; N\n    N --&gt; O[Store in command_info dictionary]\n    O --&gt; H\n</code></pre> <ul> <li>If a <code>__cmd_info__</code> method exists, it is called to retrieve command information</li> <li>Otherwise, command information is retrieved from function attributes</li> </ul>"},{"location":"user_guide/command/#setting-command-information","title":"Setting Command Information","text":"<p>You can manually set command information using the <code>set_info</code> decorator provided by the <code>ptcmd.info</code> module:</p> <pre><code>from argparse import ArgumentParser\nfrom ptcmd import Cmd, set_info\n\nclass App(Cmd):\n    _hello_parser = ArgumentParser(\"hello\")\n    _hello_parser.add_argument(\"name\", nargs=\"?\", default=\"World\", help=\"Name to greet\")\n\n    @set_info(name=\"hi\", help_category=\"Greeting\")\n    @set_info(argparser=_hello_parser)\n    def do_hello(self, argv: list[str]) -&gt; None:\n        ...\n</code></pre> <p>Alternatively, you can create an instance that implements the <code>__cmd_info__</code> method to customize the returned command information. The relevant Protocol definition is:</p> <pre><code>class CommandInfoGetter(Protocol):\n    def __cmd_info__(self, cmd_ins: \"BaseCmd\", /) -&gt; CommandInfo:\n        \"\"\"Get the command information for this command.\n\n        :param cmd_ins: The instance of the `cmd` class\n        :type cmd_ins: \"BaseCmd\"\n        :return: The command information\n        \"\"\"\n        ...\n</code></pre>"},{"location":"user_guide/command/#generic-command-wrapper-command","title":"Generic Command Wrapper \u2014 Command","text":"<p>While manually setting command information provides greater control, we typically prefer a simpler approach for defining standard commands.</p> <p><code>Command</code> is a generic command wrapper class that implements the <code>__cmd_info__</code> method, allowing command information to be set automatically or manually. Compared to directly using <code>set_info</code>, the <code>Command</code> class provides the following features:</p>"},{"location":"user_guide/command/#declarative-argument-parsing","title":"Declarative Argument Parsing","text":"<p>The <code>Command</code> class integrates the argument parsing system, enabling declarative argument parsing through the <code>@auto_argument</code> decorator and <code>Arg</code> type hints, eliminating boilerplate parameter parsing code.</p> <p>For more information on argument parsing, see Argument Parsing System.</p>"},{"location":"user_guide/command/#arbitrary-multi-level-subcommands","title":"Arbitrary Multi-level Subcommands","text":"<p><code>ptcmd</code> supports adding arbitrary levels of subcommands to a command, making it simple to build complex command hierarchies.</p>"},{"location":"user_guide/command/#basic-subcommand-usage","title":"Basic Subcommand Usage","text":"<p>Subcommands can be added to a command using the <code>add_subcommand</code> method:</p> <pre><code>from ptcmd import Cmd, auto_argument\n\nclass App(Cmd):\n    @auto_argument\n    def do_server(self):\n        \"\"\"Server management\"\"\"\n\n    @do_server.add_subcommand(\"start\")\n    def server_start(self):\n        \"\"\"Start the server\"\"\"\n        self.poutput(\"Server started\")\n\n    @do_server.add_subcommand(\"stop\")\n    def server_stop(self):\n        \"\"\"Stop the server\"\"\"\n        self.poutput(\"Server stopped\")\n</code></pre> <p>In the example above, <code>do_server</code> is the main command, while <code>server_start</code> and <code>server_stop</code> are its subcommands. Users can invoke these subcommands via <code>server start</code> and <code>server stop</code>.</p>"},{"location":"user_guide/command/#multi-level-nested-subcommands","title":"Multi-level Nested Subcommands","text":"<p><code>ptcmd</code> supports arbitrary levels of subcommand nesting:</p> <pre><code>from ptcmd import Cmd, auto_argument\n\nclass App(Cmd):\n    @auto_argument\n    def do_server(self):\n        \"\"\"Server management\"\"\"\n\n    @do_server.add_subcommand(\"db\")\n    def db(self):\n        \"\"\"Database management\"\"\"\n\n    @db.add_subcommand(\"migrate\")\n    def migrate(self, version: str):\n        \"\"\"Perform database migration\"\"\"\n        self.poutput(f\"Migrating to version {version}...\")\n\n    @do_server.add_subcommand(\"cache\")\n    def cache(self):\n        \"\"\"Cache management\"\"\"\n\n    @cache.add_subcommand(\"clear\")\n    def clear(self, confirm: bool = False):\n        \"\"\"Clear cache\"\"\"\n        if confirm:\n            self.poutput(\"Cache cleared\")\n        else:\n            self.poutput(\"Please add --confirm to confirm the operation\")\n</code></pre> <p>In this example, we've created a two-level subcommand structure: - <code>server</code> (main command)   - <code>db</code> (subcommand)     - <code>migrate</code> (second-level subcommand)   - <code>cache</code> (subcommand)     - <code>clear</code> (second-level subcommand)</p> <p>Users can invoke these features with the following commands: - <code>server db migrate v1.0</code> - <code>server cache clear --confirm</code></p>"},{"location":"user_guide/command/#implementation-principles","title":"Implementation Principles","text":"<p>The system implements command context propagation through <code>ArgumentParser</code>'s <code>defaults</code> mechanism:</p> <ul> <li>Leaf Node Binding: During subcommand parser construction, the leaf node command instance is injected into the <code>defaults</code> dictionary</li> <li>Override Behavior: When a subcommand is triggered, it overrides the parent command's <code>defaults</code>, naturally forming a reference to the deepest command</li> <li>Parsed Result Association: The final namespace's <code>__cmd_ins__</code> attribute directly references the leaf node command instance</li> </ul> <p>This design cleverly leverages <code>argparse</code>'s native mechanism\u2014subcommand parsers override parent command defaults\u2014allowing the system to directly access the terminal command execution context after standard parsing completes, without additional lookups.</p> <p>The system uses a lightweight reference chain to build command hierarchies:</p> <pre><code>flowchart BT\n    F[Third-level Subcommand] --&gt;|_parent| D[Second-level Subcommand]\n    D --&gt;|_parent| B[First-level Subcommand]\n    E[Another Second-level Subcommand] --&gt;|_parent| B\n    B --&gt;|_parent| A[Root Command]\n    C[Another First-level Subcommand] --&gt;|_parent| A\n</code></pre> <p>Core mechanisms:</p> <ul> <li>Reverse Reference: Each subcommand instance only stores a reference to its direct parent command</li> <li>Dynamic Construction: The command tree forms naturally during parsing, without requiring predefined structure</li> <li>Path Reconstruction: Complete invocation paths can be reconstructed by recursively accessing the <code>_parent</code> attribute</li> <li>Low Overhead: Each command only adds a single reference relationship, avoiding centralized registries</li> </ul> <p>This design fully leverages <code>argparse</code>'s subcommand mechanism, implementing arbitrary-depth command nesting through minimal extensions.</p> <p>Execution flow focuses on post-parsing processing:</p> <pre><code>flowchart LR\n    Q[argparse parsing complete] --&gt; R[Chain Reconstruction]\n    R --&gt; S[Forward Execution]\n</code></pre> <ol> <li>Chain Reconstruction Phase:</li> <li>Retrieve the leaf node command instance from <code>__cmd_ins__</code></li> <li>Traverse upward through <code>_parent</code> references to build the complete command chain</li> <li> <p>Verify chain integrity and node status</p> </li> <li> <p>Forward Execution Phase:</p> </li> <li>Reverse the command chain to root\u2192leaf order</li> <li>Execute each command level sequentially, passing intermediate results</li> <li>Return the leaf node's final execution result</li> </ol> <p>The key value lies in: fully utilizing standard parsing results, reconstructing the execution path from the leaf node before forward execution. The system doesn't interfere with <code>argparse</code>'s parsing process, only injecting execution logic after parsing completes\u2014maintaining compatibility with the standard library while supporting complex command structures.</p>"},{"location":"user_guide/command/#help-system","title":"Help System","text":"<p><code>ptcmd</code> provides two complementary help information mechanisms that serve different scenarios:</p>"},{"location":"user_guide/command/#argumentparser-built-in-help-system","title":"ArgumentParser Built-in Help System","text":"<p>This is the standard command-line help system, triggered by <code>-h</code>/<code>--help</code> parameters, providing detailed command parameter information:</p>"},{"location":"user_guide/command/#basic-usage","title":"Basic Usage","text":"<pre><code>command -h\n</code></pre>"},{"location":"user_guide/command/#working-principle","title":"Working Principle","text":"<ul> <li>Provided by Python's standard library <code>argparse</code> module</li> <li>Automatically parses command parameter structure and generates formatted help information</li> <li>Displays:</li> <li>Command description (from ArgumentParser's description parameter)</li> <li>All available parameters and their explanations</li> <li>Parameter types, default values, and constraints</li> <li>Subcommand list (if applicable)</li> </ul>"},{"location":"user_guide/command/#configuration","title":"Configuration","text":"<p>Configure help content through the ArgumentParser object: <pre><code>_hello_parser = ArgumentParser(\n    \"hello\", \n    description=\"Greet users. Use 'hello [name]' to specify a name\",\n    epilog=\"See documentation for more examples\"\n)\n\n@set_info(argparser=_hello_parser)\ndef do_hello(self, argv: list[str]) -&gt; None:\n    ...\n</code></pre></p>"},{"location":"user_guide/command/#multi-level-subcommand-support","title":"Multi-level Subcommand Support","text":"<ul> <li><code>server -h</code> displays an overview of the server command and its subcommands</li> <li><code>server start -h</code> displays detailed parameter information for the start subcommand</li> </ul>"},{"location":"user_guide/command/#help-command","title":"help Command","text":"<p>This is the advanced command help system provided by <code>ptcmd</code>, triggered by the <code>help</code> command, offering a more user-friendly interactive help experience:</p>"},{"location":"user_guide/command/#basic-usage_1","title":"Basic Usage","text":"<pre><code>help            # Display overview of all available commands\nhelp command    # Display brief description of a specific command\nhelp command -v # Display detailed parameter information for a specific command\n?               # Equivalent to help\n?command        # Equivalent to help command\n</code></pre>"},{"location":"user_guide/command/#help-information-sources","title":"Help Information Sources","text":"<p>The <code>ptcmd</code> help command retrieves information from the following locations:</p> <ol> <li> <p>Command Docstrings:    <pre><code>def do_hello(self, argv: list[str]) -&gt; None:\n    \"\"\"Greet users. Use 'hello [name]' to specify a name\"\"\"\n    ...\n</code></pre>    This will serve as the brief description for <code>help hello</code></p> </li> <li> <p>Dynamic help_ Methods:    <pre><code>def help_hello(self) -&gt; str:\n    \"\"\"Dynamically generate help information for hello command\"\"\"\n    return \"Current user: \" + self.current_user + \"\\nUsage: hello [name]\"\n</code></pre>    Takes precedence over docstrings <li> <p>Command Metadata:    <pre><code>@set_info(help_category=\"Greeting\")\ndef do_hello(self, argv: list[str]) -&gt; None:\n    \"\"\"Greet users\"\"\"\n    ...\n</code></pre>    Used for organizing command categorization</p> </li>"},{"location":"user_guide/command/#help-categorization-and-organization","title":"Help Categorization and Organization","text":"<ul> <li>Commands can be grouped using the <code>help_category</code> parameter</li> <li>Hidden commands (<code>hidden=True</code>) won't appear in help output</li> <li>Disabled commands (<code>disabled=True</code>) will be displayed but marked as unavailable</li> </ul>"},{"location":"user_guide/command/#coordination-between-help-systems","title":"Coordination Between Help Systems","text":"Feature ArgumentParser (-h) help Command Primary Purpose Detailed parameter reference Command overview and quick reference Trigger Method <code>command -h</code> <code>help</code> or <code>?</code> Content Depth Detailed parameter explanations Brief command descriptions Dynamic Content Limited (primarily static) Supports dynamic generation Best Scenario When detailed parameter usage is needed When browsing available commands and basic usage"},{"location":"user_guide/core/","title":"Core Framework - BaseCmd/Cmd","text":"<p>The <code>BaseCmd</code> and <code>Cmd</code> classes form the core framework of <code>ptcmd</code>, enabling users to create interactive command-line applications through inheritance.</p> <p>The difference between <code>BaseCmd</code> and <code>Cmd</code> is that the <code>Cmd</code> class provides three built-in commands (<code>help</code>, <code>exit</code>, and <code>shell</code>), while the <code>BaseCmd</code> class has no built-in commands and requires users to define all commands themselves.</p>"},{"location":"user_guide/core/#compatibility","title":"Compatibility","text":"<p>Note that <code>ptcmd</code> is not compatible with the standard library <code>cmd</code>. This mainly depends on the following aspects:</p> <ul> <li>Command parameters: <code>ptcmd</code> passes pre-split parameter lists to command methods, while <code>cmd</code> passes a string with the command name removed.</li> </ul> <p>Ptcmd</p> <pre><code>from ptcmd import BaseCmd\n\nclass MyApp(BaseCmd):\n    def do_hello(self, argv: list[str]) -&gt; None:\n        ...\n</code></pre> <p>Cmd</p> <pre><code>from cmd import Cmd\n\nclass MyApp(Cmd):\n    def do_hello(self, arg: str) -&gt; None:\n        ...\n</code></pre> <ul> <li>Command collection method: <code>cmd</code> does not pre-collect commands; it searches for and executes commands by reading instance attributes at runtime, allowing dynamic command addition after instance initialization. In contrast, <code>ptcmd</code> has a more robust command collection system where all commands must be pre-collected and command information obtained during initialization. Commands cannot be simply added or removed through attribute modifications. See Command Collection for details.</li> </ul> <p>If you're looking for an interactive command-line framework compatible with the standard library <code>cmd</code>, please use <code>cmd2</code>.</p>"},{"location":"user_guide/core/#command-collection","title":"Command Collection","text":"<p><code>BaseCmd</code> collects commands through method name prefixes defined in the class. By default, all methods starting with <code>do_</code> are collected as commands.</p> <p>Command collection occurs during class creation, so new attributes added after creation will not be collected as commands. To add new commands, for classes you should explicitly modify the <code>__commands__</code> attribute, and for instances you need to change the <code>command_info</code> attribute.</p> <pre><code>graph TD\n    A[BaseCmd Subclass Definition] --&gt; C[Inherit Parent Class Command Set];\n    C --&gt; D[Iterate All Class Attributes];\n    D --&gt; E{Does Attribute Name Start With\n        COMMAND_FUNC_PREFIX?};\n    E --&gt;|Yes| F[Add Attribute to Command Set];\n    E --&gt;|No| G[Ignore Attribute];\n    F --&gt; H[Class Creation Complete];\n    G --&gt; H;\n    H --&gt; I[Retrieve Command Information];\n    I --&gt; J{Are Commands Duplicated?};\n    J --&gt;|Yes| K[Raise ValueError Exception];\n    J --&gt;|No| L[Store Command Information in\n        command_info Dictionary];\n    L --&gt; M[Command Collection Complete];\n\n    subgraph Command Collection Phase\n        C;\n        D;\n        E;\n        F;\n        G;\n        H;\n    end;\n\n    subgraph Initialization Phase\n        I;\n        J;\n        K;\n        L;\n        M;\n    end;\n</code></pre>"},{"location":"user_guide/core/#changing-command-prefix","title":"Changing Command Prefix","text":"<p>The command prefix is specified by the class attribute <code>COMMAND_FUNC_PREFIX</code>:</p> <pre><code>class BaseCmd(object, metaclass=ABCMeta):\n    ...\n    COMMAND_FUNC_PREFIX = \"do_\"\n</code></pre> <p>You can change the command recognition prefix by modifying the class attribute <code>COMMAND_FUNC_PREFIX</code> when creating a subclass.</p> <p>Warning</p> <p>This is a dangerous operation. You must ensure:</p> <ol> <li>Do not modify the command prefix of existing classes, as this won't change already collected command names and will only cause errors.</li> <li>When changing the command prefix, avoid inheriting from parent classes that already have commands, as this will cause all parent class commands to become invalid.</li> <li>In multiple inheritance scenarios, all parent classes must use the same command prefix.</li> </ol>"},{"location":"user_guide/core/#inputoutput","title":"Input/Output","text":"<p>Input and output are core features of <code>ptcmd</code>, allowing users to input commands and receive execution results. <code>ptcmd</code> provides rich I/O capabilities including command prompts, auto-completion, history, result formatting, and error handling.</p>"},{"location":"user_guide/core/#output","title":"Output","text":"<p>The <code>Cmd</code> object provides the following built-in output methods. When possible, use these to prevent background task output from interrupting interactive input:</p> <ul> <li><code>cmd.stdout</code>: A <code>prompt_toolkit</code> <code>StdoutProxy</code> object compatible with <code>io.TextIOWrapper</code>, can be used to replace <code>sys.stdout</code>.</li> <li><code>cmd.console</code>: A <code>rich.console.Console</code> object built on <code>cmd.stdout</code>, supporting rich text output.</li> <li><code>cmd.poutput()</code> series: Simple wrappers around <code>cmd.console</code>.</li> </ul>"},{"location":"user_guide/core/#non-interactive-input","title":"Non-interactive Input","text":"<p>If the input stream is non-interactive, <code>BaseCmd</code> will skip creating the <code>prompt_toolkit</code> interactive session and fall back to standard file input logic. This allows <code>ptcmd</code> applications to be called via input redirection or pipelines to execute one or multiple commands.</p> Input RedirectionPipeline Connection <pre><code>$ python examples/hello.py &lt;&lt;EOF\n&gt; hello\n&gt; hello Alice\n&gt; EOF\nHello World!\nHello Alice!\n</code></pre> <pre><code>$ echo -e \"hello\\nhello Alice\" | python examples/hello.py \nHello, World!\nHello, Alice!\n</code></pre>"},{"location":"user_guide/core/#custom-inputoutput-streams","title":"Custom Input/Output Streams","text":"<p><code>BaseCmd</code> uses standard input/output by default but also supports custom streams similar to <code>cmd.Cmd</code>.</p> <pre><code>out = io.StringIO()\ncmd = BaseCmd(sys.stdin, out)\ncmd.cmdloop()\nprint(out.getvalue())\n</code></pre>"},{"location":"user_guide/core/#command-sets","title":"Command Sets","text":"<p>Currently <code>ptcmd</code> doesn't directly support command sets, but they can be implemented through diamond inheritance.</p> <p>```python import sys from ptcmd import Cmd</p> <p>class App(Cmd):     \"\"\"     Define common properties and methods     \"\"\"</p> <p>class App1(App):     \"\"\"     Define command set 1     \"\"\"     def do_cmd1(self, argv: list[str]) -&gt; None:         ...</p> <p>class App2(App):     \"\"\"     Define command set 2     \"\"\"     def do_cmd2(self, argv: list[str]) -&gt; None:         ...</p> <p>class Cli(App1, App2):     \"\"\"     Merge command sets using multiple inheritance     \"\"\"</p> <p>if name == 'main':     sys.exit(Cli().cmdloop())</p>"},{"location":"zh/","title":"\u6b22\u8fce\u6765\u5230ptcmd\u6587\u6863","text":"<p>\u4e00\u4e2a\u73b0\u4ee3\u5316\u7684\u57fa\u4e8e<code>prompt_toolkit</code>\u7684\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u7a0b\u5e8f\u6784\u5efa\u5e93</p> <p> </p> <p><code>ptcmd</code>\u662f\u4e00\u4e2aPython\u6846\u67b6\uff0c\u901a\u8fc7\u63d0\u4f9b\u58f0\u660e\u5f0f\u547d\u4ee4\u5b9a\u4e49\u3001\u81ea\u52a8\u53c2\u6570\u89e3\u6790\u548c\u4e30\u5bcc\u7684\u4ea4\u4e92\u7279\u6027\u6765\u73b0\u4ee3\u5316\u547d\u4ee4\u884c\u754c\u9762\u5f00\u53d1\u3002\u57fa\u4e8e<code>prompt_toolkit</code>\u548c<code>rich</code>\u6784\u5efa\uff0c\u5b83\u5f25\u5408\u4e86Python\u57fa\u7840<code>cmd</code>\u6a21\u5757\u4e0e<code>cmd2</code>\u7b49\u5168\u529f\u80fdCLI\u6846\u67b6\u4e4b\u95f4\u7684\u5dee\u8ddd\uff0c\u4ee5\u6700\u5c0f\u7684\u590d\u6742\u5ea6\u63d0\u4f9b\u6700\u4f73\u7684\u4ea4\u4e92\u4f53\u9a8c\u3002</p>"},{"location":"zh/#_1","title":"\u6587\u6863\u7ed3\u6784","text":"<ul> <li>\u6838\u5fc3\u6982\u5ff5: \u4ecb\u7ecd ptcmd \u7684\u57fa\u7840\u6784\u5efa\u6a21\u5757\uff0c\u5305\u62ec\u5e94\u7528\u7a0b\u5e8f\u4e3b\u7ed3\u6784\u548c\u5173\u952e\u7ec4\u4ef6</li> <li>\u53c2\u6570\u5904\u7406: \u8be6\u7ec6\u8bf4\u660e\u547d\u4ee4\u53c2\u6570\u7684\u5b9a\u4e49\u3001\u9a8c\u8bc1\u548c\u7c7b\u578b\u8f6c\u6362\u673a\u5236</li> <li>\u547d\u4ee4\u5b9e\u73b0: \u6df1\u5165\u8bb2\u89e3\u547d\u4ee4\u5b9a\u4e49\u3001\u6267\u884c\u6d41\u7a0b\u548c\u9ad8\u7ea7\u547d\u4ee4\u6a21\u5f0f</li> </ul> <p>\u6709\u5173<code>ptcmd</code>\u9ad8\u7ea7\u529f\u80fd\uff08\u5982\u5f02\u6b65\u652f\u6301\u548c\u5bcc\u6587\u672c\u683c\u5f0f\u5316\uff09\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u201c\u5173\u952e\u7279\u6027\u201d\u3002\u6709\u5173\u6838\u5fc3\u6846\u67b6\u7c7b\u7684\u6df1\u5165\u4ecb\u7ecd\uff0c\u8bf7\u53c2\u9605\u201c\u7528\u6237\u6307\u5357\u201d.</p>"},{"location":"zh/feature/","title":"\u7279\u6027","text":"<p>\u672c\u6587\u6863\u5168\u9762\u6982\u8ff0\u4e86<code>ptcmd</code>\u7684\u6838\u5fc3\u529f\u80fd\u548c\u7279\u8272\u3002\u5b83\u89e3\u91ca\u4e86\u8be5\u6846\u67b6\u5982\u4f55\u7ed3\u5408\u73b0\u4ee3 Python\u5e93\uff0c\u521b\u5efa\u5f3a\u5927\u7684CLI\u5f00\u53d1\u4f53\u9a8c\u3002\u6709\u5173\u6838\u5fc3\u6846\u67b6\u7c7b\u7684\u5b9e\u73b0\u7ec6\u8282\uff0c\u8bf7\u53c2\u9605\u6838\u5fc3\u6846\u67b6\u3002\u6709\u5173\u8be6\u7ec6\u7684\u7528\u6cd5\u6a21\u5f0f\u548c\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605\u793a\u4f8b\u548c\u7528\u6cd5\u3002</p>"},{"location":"zh/feature/#_2","title":"\u5f3a\u5927\u7684\u4ea4\u4e92\u4f53\u9a8c","text":"<p><code>ptcmd</code>\u57fa\u4e8e\u73b0\u4ee3\u5316\u7684\u4ea4\u4e92\u5e93<code>prompt_toolkit</code>\u6784\u5efa\uff0c\u63d0\u4f9b\u8d85\u8d8a\u57fa\u672c\u6587\u672c\u8f93\u5165\u8f93\u51fa\u7684\u73b0\u4ee3\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u4f53\u9a8c\u3002\u8be5\u6846\u67b6\u81ea\u52a8\u5904\u7406\u590d\u6742\u7684\u7ec8\u7aef\u4ea4\u4e92\uff0c\u63d0\u4f9b\u8865\u5168\u548c\u8bed\u6cd5\u9ad8\u4eae\u3002</p> <p></p>"},{"location":"zh/feature/#_3","title":"\u58f0\u660e\u5f0f\u53c2\u6570\u89e3\u6790","text":"<p><code>ptcmd</code>\u901a\u8fc7<code>@auto_argument</code>\u88c5\u9970\u5668\u548c<code>Arg</code>\u7c7b\u578b\u63d0\u793a\u6d88\u9664\u4e86\u6837\u677f\u53c2\u6570\u89e3\u6790\u4ee3\u7801\u3002\u8be5\u7cfb\u7edf\u81ea\u52a8\u6839\u636e\u51fd\u6570\u7b7e\u540d\u751f\u6210<code>ArgumentParser</code>\u5b9e\u4f8b\uff0c\u4f7f\u547d\u4ee4\u5b9a\u4e49\u65e2\u7b80\u6d01\u53c8\u7c7b\u578b\u5b89\u5168\u3002</p> <pre><code>from ptcmd import Cmd, Arg, auto_argument\n\nclass MathApp(Cmd):\n    @auto_argument\n    def do_add(\n        self, \n        x: float, \n        y: float,\n        *,\n        verbose: Arg[bool, \"-v\", \"--verbose\", {\"help\": \"\u8be6\u7ec6\u8f93\u51fa\"}] = False\n    ) -&gt; None:\n        \"\"\"\u4e24\u6570\u76f8\u52a0\"\"\"\n        result = x + y\n        if verbose:\n            self.poutput(f\"{x} + {y} = {result}\")\n        else:\n            self.poutput(result)\n</code></pre> <p>\u4ee5\u4e0a\u793a\u4f8b\u7b49\u4ef7\u4e8e\u4ee5\u4e0b\u4ee3\u7801\uff1a</p> <pre><code>from ptcmd import Cmd, Arg, auto_argument\nfrom argparse import ArgumentParser\n\nclass MathApp(Cmd):\n    def do_add(self, argv: list[str]) -&gt; None:\n        parser = ArgumentParser(prog=\"add\", description=\"\u4e24\u6570\u76f8\u52a0\")\n        parser.add_argument(\"x\", type=float)\n        parser.add_argument(\"y\", type=float)\n        parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n        ns = parser.parse_args(argv)\n        result = ns.x + ns.y\n        if ns.verbose:\n            self.poutput(f\"{ns.x} + {ns.y} = {result}\")\n        else:\n            self.poutput(result)\n</code></pre> <p>\u5982\u679c\u4f60\u6b63\u5728\u4f7f\u7528\u7c7b\u578b\u68c0\u6d4b\u5668\uff0c\u4f7f\u7528<code>Arg</code>\u5f80\u5f80\u4f1a\u88ab\u7c7b\u578b\u68c0\u67e5\u5668\u89c6\u4e3a\u9519\u8bef\uff0c\u53ef\u4ee5\u5728\u884c\u5c3e\u6dfb\u52a0<code># noqa: F821,F722,B002</code>\u8ba9\u7c7b\u578b\u68c0\u67e5\u5668\u5ffd\u7565\u8fd9\u4e9b\u95ee\u9898\u3002\u5982\u679c\u4f60\u771f\u7684\u975e\u5e38\u4ecb\u610f\uff0c\u53ef\u4ee5<code>Annotated</code>\u4e0e<code>Argument</code>\u6765\u66f4\u52a0\u5408\u6cd5\u7684\u58f0\u660e\u53c2\u6570\uff0c\u4f46\u8fd9\u5199\u8d77\u6765\u66f4\u52a0\u9ebb\u70e6\uff0c\u540c\u65f6\u4f1a\u5931\u53bb\u4e00\u4e9b\u81ea\u52a8\u63a8\u65ad\u7279\u6027\u3002</p> <pre><code>from typing import Annotated\nfrom ptcmd import Cmd, Argument, auto_argument\n\nclass MathApp(Cmd):\n    @auto_argument\n    def do_add(\n        self, \n        x: float, \n        y: float,\n        *,\n        verbose: Annotated[bool, Argument(\"-v\", \"--verbose\", action=\"store_true\")] = False\n    ) -&gt; None:\n        \"\"\"\u4e24\u6570\u76f8\u52a0\"\"\"\n        result = x + y\n        if verbose:\n            self.poutput(f\"{x} + {y} = {result}\")\n        else:\n            self.poutput(result)\n</code></pre>"},{"location":"zh/feature/#_4","title":"\u5bcc\u6587\u672c\u8f93\u51fa","text":"<p><code>ptcmd</code>\u96c6\u6210\u4e86<code>rich</code>\u5e93\uff0c\u63d0\u4f9b\u9ad8\u7ea7\u7684\u6587\u672c\u683c\u5f0f\u5316\u3001\u6837\u5f0f\u548c\u5e03\u5c40\u529f\u80fd\u3002\u8be5\u6846\u67b6\u5c01\u88c5\u4e86 <code>rich.Console</code>\u529f\u80fd\uff0c\u540c\u65f6\u4fdd\u6301\u4e0e\u73b0\u6709\u57fa\u4e8e\u6253\u5370\u7684\u4ee3\u7801\u7684\u517c\u5bb9\u6027\u3002</p> <p><code>Cmd</code>\u7c7b\u5411\u5916\u66b4\u9732\u4e86<code>console</code>\u5c5e\u6027\uff0c\u8be5\u5c5e\u6027\u662f\u4e00\u4e2a<code>rich.Console</code>\u5bf9\u8c61\uff0c\u7528\u4e8e\u6253\u5370\u5bcc\u6587\u672c\u3002\u4e5f\u53ef\u4ee5\u4f7f\u7528\u5c01\u88c5\u597d\u7684<code>poutput</code>\u3001<code>pwarning</code>\u3001<code>perror</code>\u7b49\u5c01\u88c5\u597d\u7684\u65b9\u6cd5\uff0c\u95f4\u63a5\u901a\u8fc7<code>console</code>\u6253\u5370\u5bcc\u6587\u672c\u3002</p> <pre><code>class RichApp(Cmd):\n    def do_hello(self, argv: list[str]) -&gt; None:\n        # \u4f7f\u7528rich mackup\u6587\u672c\u8fdb\u884c\u8f93\u51fa\n        self.poutput(f\"[bold blue]Hello, World![/bold blue]\")\n</code></pre> <p>prompt\u90e8\u5206\u652f\u6301\u4f7f\u7528<code>rich</code>\u6216<code>prompt_toolkit</code>\u7684\u5bcc\u6587\u672c\u6837\u5f0f\u3002</p> <pre><code>class RichTextApp(Cmd):\n    DEFAULT_PROMPT = \"[cmd.prompt]rich[/cmd.prompt]&gt; \"\n\n    @auto_argument\n    def do_test_card(self) -&gt; None:\n        \"\"\"show rich text\"\"\"\n        self.poutput(make_test_card())\n</code></pre> <p></p>"},{"location":"zh/feature/#_5","title":"\u81ea\u52a8\u547d\u4ee4\u8865\u5168","text":"<p><code>ptcmd</code>\u80fd\u591f\u6839\u636e\u547d\u4ee4\u7684\u63d0\u4f9b\u7684<code>ArgumentParser</code>\u5b9e\u4f8b\u4fe1\u606f\uff0c\u81ea\u52a8\u7406\u89e3\u547d\u4ee4\u7ed3\u6784\u3001\u53c2\u6570\u7c7b\u578b\u548c\u53ef\u7528\u503c\uff0c\u901a\u8fc7<code>prompt_toolkit</code>\u7684<code>Completer</code>\u5b9e\u73b0\u81ea\u52a8\u547d\u4ee4\u8865\u5168\u3002</p> <p>\u8865\u5168\u9ed8\u8ba4\u4f7f\u7528\u63a5\u8fd1\u7ec8\u7aef\u8865\u5168\u65b9\u5f0f\u7684<code>READLINE_LIKE</code>\u98ce\u683c\u3002</p> <p></p> <p>\u4e5f\u53ef\u4ee5\u4f7f\u7528<code>prompt_toolkit</code>\u63d0\u4f9b\u7684<code>MULTI_COLUMN</code>\u8865\u5168\u98ce\u683c\u3002</p> <p></p>"},{"location":"zh/feature/#_6","title":"\u4efb\u610f\u591a\u7ea7\u5b50\u547d\u4ee4","text":"<p><code>ptcmd</code>\u652f\u6301\u4e3a\u4e00\u4e2a\u547d\u4ee4\u6dfb\u52a0\u4efb\u610f\u591a\u7ea7\u5b50\u547d\u4ee4\u3002</p> <pre><code>from ptcmd import Cmd, auto_argument\n\nclass App(Cmd):\n    @auto_argument\n    def do_server(self):\n        \"\"\"\u670d\u52a1\u5668\u7ba1\u7406\"\"\"\n\n    @do_server.add_subcommand(\"db\")\n    def db(self):\n        \"\"\"\u6570\u636e\u5e93\u7ba1\u7406\"\"\"\n\n    @db.add_subcommand(\"migrate\")\n    def migrate(self, version: str):\n        \"\"\"\u6267\u884c\u6570\u636e\u5e93\u8fc1\u79fb\"\"\"\n        self.poutput(f\"\u6b63\u5728\u8fc1\u79fb\u5230\u7248\u672c {version}...\")\n\n    @do_server.add_subcommand(\"cache\")\n    def cache(self):\n        \"\"\"\u7f13\u5b58\u7ba1\u7406\"\"\"\n\n    @cache.add_subcommand(\"clear\")\n    def clear(self, confirm: bool = False):\n        \"\"\"\u6e05\u9664\u7f13\u5b58\"\"\"\n        if confirm:\n            self.poutput(\"\u7f13\u5b58\u5df2\u6e05\u9664\")\n        else:\n            self.poutput(\"\u8bf7\u6dfb\u52a0--confirm\u53c2\u6570\u786e\u8ba4\u64cd\u4f5c\")\n</code></pre>"},{"location":"zh/feature/#_7","title":"\u539f\u751f\u5f02\u6b65\u652f\u6301","text":"<p>\u5f97\u76ca\u4e8e<code>prompt_toolkit</code>\u4f18\u79c0\u7684\u5f02\u6b65\u652f\u6301\uff0c<code>ptcmd</code>\u4e5f\u539f\u751f\u652f\u6301\u5f02\u6b65\u547d\u4ee4\u3002</p> <pre><code>from typing import Any, Optional\nfrom aiohttp import ClientSession\nfrom ptcmd import Cmd, auto_argument\n\n\nclass RequestApp(Cmd):\n    DEFAULT_PROMPT = \"[cmd.prompt]request[/cmd.prompt]&gt; \"\n\n    @auto_argument\n    async def do_get(self, url: str, *, params: Optional[str] = None) -&gt; None:\n        \"\"\"Send a GET request to the specified URL\"\"\"\n        async with ClientSession() as session:\n            async with session.get(url, params=params) as response:\n                content = await response.text()\n                self.poutput(f\"Response from {url}:\\n{content}\")\n\n    @auto_argument\n    async def do_post(self, url: str, data: Any) -&gt; None:\n        \"\"\"Send a POST request to the specified URL with data\"\"\"\n        async with ClientSession() as session:\n            async with session.post(url, data=data) as response:\n                content = await response.text()\n                self.poutput(f\"Response from {url}:\\n{content}\")\n\n\nif __name__ == \"__main__\":\n    RequestApp().cmdloop()\n</code></pre>"},{"location":"zh/interactive_cli/","title":"\u4ec0\u4e48\u662f\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528","text":""},{"location":"zh/interactive_cli/#_2","title":"\u6838\u5fc3\u6982\u5ff5","text":"<p>\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\uff08Interactive Command-Line Applications\uff09\u662f\u4e00\u79cd\u5141\u8bb8\u7528\u6237\u4e0e\u7a0b\u5e8f\u8fdb\u884c\u5b9e\u65f6\u4ea4\u4e92\u7684\u547d\u4ee4\u884c\u7a0b\u5e8f\u3002\u4e0e\u4f20\u7edf\u7684\u547d\u4ee4\u884c\u5e94\u7528\uff08Command-Line Applications\uff09\u4e0d\u540c\uff0c\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\uff0c\u5e76\u975e\u4e00\u6b21\u6027\u8bfb\u53d6\u6240\u6709\u8f93\u5165\u5e76\u4ea7\u751f\u8f93\u51fa\u540e\u5c31\u7ed3\u675f\u8fd0\u884c\uff0c\u800c\u662f\u4f1a\u6301\u7eed\u8fd0\u884c\uff0c\u7b49\u5f85\u7528\u6237\u8f93\u5165\u5404\u79cd\u547d\u4ee4\uff0c\u5e76\u5373\u65f6\u5bf9\u8fd9\u4e9b\u547d\u4ee4\u505a\u51fa\u54cd\u5e94\u3002\u5b83\u5c31\u50cf\u662f\u7528\u6237\u4e0e\u8ba1\u7b97\u673a\u4e4b\u95f4\u7684\u4e00\u573a\u5bf9\u8bdd\uff0c\u7528\u6237\u4e0d\u65ad\u63d0\u51fa\u6307\u4ee4\uff0c\u7a0b\u5e8f\u5219\u6839\u636e\u8fd9\u4e9b\u6307\u4ee4\u53cd\u9988\u76f8\u5e94\u7684\u7ed3\u679c\u3002</p> <p>\u4ee5\u5e38\u89c1\u7684 Python \u89e3\u91ca\u5668\u7684\u4ea4\u4e92\u5f0f\u6a21\u5f0f\u4e3a\u4f8b\uff0c\u5f53\u4f60\u5728\u547d\u4ee4\u884c\u4e2d\u8f93\u5165python\u5e76\u56de\u8f66\u540e\uff0c\u4f1a\u8fdb\u5165 Python \u7684\u4ea4\u4e92\u5f0f\u73af\u5883\uff08REPL,Read-Eval-Print Loop\uff09\uff0c\u63d0\u793a\u7b26\u901a\u5e38\u4e3a&gt;&gt;&gt;\u3002\u6b64\u65f6\uff0c\u4f60\u53ef\u4ee5\u9010\u884c\u8f93\u5165 Python \u4ee3\u7801\uff0c\u89e3\u91ca\u5668\u4f1a\u7acb\u5373\u6267\u884c\u4f60\u8f93\u5165\u7684\u4ee3\u7801\u5e76\u8fd4\u56de\u7ed3\u679c\u3002\u6bd4\u5982\u8f93\u5165<code>print(\"Hello, World!\")</code>\uff0c\u89e3\u91ca\u5668\u4f1a\u9a6c\u4e0a\u8f93\u51faHello, World!\u3002\u8fd9\u79cd\u4ea4\u4e92\u662f\u5373\u65f6\u7684\uff0c\u7528\u6237\u53ef\u4ee5\u6839\u636e\u4e0a\u4e00\u6761\u547d\u4ee4\u7684\u6267\u884c\u7ed3\u679c\uff0c\u7075\u6d3b\u5730\u51b3\u5b9a\u4e0b\u4e00\u6761\u8f93\u5165\u4ec0\u4e48\u547d\u4ee4\uff0c\u5c31\u50cf\u5728\u4e0e\u7a0b\u5e8f\u8fdb\u884c\u5b9e\u65f6\u4ea4\u6d41\u4e00\u6837\u3002</p> <p>\u518d\u6bd4\u5982\u4e00\u4e9b\u6570\u636e\u5e93\u5ba2\u6237\u7aef\u7684\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5de5\u5177\uff0c\u5982 MySQL \u7684\u547d\u4ee4\u884c\u5ba2\u6237\u7aef\u3002\u7528\u6237\u767b\u5f55\u5230 MySQL \u5ba2\u6237\u7aef\u540e\uff0c\u53ef\u5728\u547d\u4ee4\u884c\u4e2d\u8f93\u5165\u5404\u79cd SQL \u8bed\u53e5\u6765\u67e5\u8be2\u3001\u4fee\u6539\u6570\u636e\u5e93\u3002\u6bcf\u8f93\u5165\u4e00\u6761\u6709\u6548\u7684 SQL \u547d\u4ee4\uff0c\u5ba2\u6237\u7aef\u5c31\u4f1a\u6267\u884c\u8be5\u547d\u4ee4\u5e76\u8fd4\u56de\u76f8\u5e94\u7684\u67e5\u8be2\u7ed3\u679c\u6216\u64cd\u4f5c\u53cd\u9988\u3002\u5982\u679c\u67e5\u8be2\u6570\u636e\uff0c\u4f1a\u663e\u793a\u7b26\u5408\u6761\u4ef6\u7684\u6570\u636e\u884c\uff1b\u5982\u679c\u6267\u884c\u6570\u636e\u63d2\u5165\u64cd\u4f5c\uff0c\u4f1a\u544a\u77e5\u64cd\u4f5c\u662f\u5426\u6210\u529f\u7b49\u3002\u8fd9\u79cd\u6301\u7eed\u4ea4\u4e92\u7684\u8fc7\u7a0b\uff0c\u8ba9\u7528\u6237\u80fd\u591f\u6839\u636e\u6570\u636e\u5e93\u7684\u5f53\u524d\u72b6\u6001\uff0c\u9010\u6b65\u6df1\u5165\u5730\u8fdb\u884c\u6570\u636e\u64cd\u4f5c\u548c\u7ba1\u7406\u3002</p>"},{"location":"zh/interactive_cli/#_3","title":"\u4e0e\u4e00\u822c\u547d\u4ee4\u884c\u7a0b\u5e8f\u5bf9\u6bd4","text":"<p>\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u4e0e\u4e00\u822c\u547d\u4ee4\u884c\u7a0b\u5e8f\u7684\u6838\u5fc3\u533a\u522b\u5728\u4e8e\u72b6\u6001\uff0c\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u4f1a\u4fdd\u6301\u4e0a\u4e0b\u6587\u72b6\u6001\uff0c\u4e0d\u9700\u8981\u501f\u52a9\u5916\u90e8\u6587\u4ef6\u6216\u5176\u4ed6\u65b9\u5f0f\u6765\u4f20\u9012\u72b6\u6001\u3002\u800c\u4e00\u822c\u547d\u4ee4\u884c\u7a0b\u5e8f\u6bcf\u6b21\u6267\u884c\u90fd\u662f\u72ec\u7acb\u7684\u5355\u6b21\u64cd\u4f5c\uff0c\u9700\u8981\u663e\u5f0f\u4f20\u9012\u72b6\u6001\u3002</p> <p>\u56e0\u6b64\uff0c\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u66f4\u9002\u7528\u4e8e\u9700\u8981\u4fdd\u6301\u4e0a\u4e0b\u6587\u72b6\u6001\u7684\u573a\u666f\uff0c\u5982\u5404\u79cd\u4f9d\u8d56\u4e8e\u7f51\u7edc\u56de\u8bdd\u7684\u7ba1\u7406\u5de5\u5177\u6216\u4f9d\u8d56\u8fdb\u7a0b\u72b6\u6001\u7684debug\u5de5\u5177\u3002\u800c\u4e00\u822c\u547d\u4ee4\u884c\u7a0b\u5e8f\u66f4\u9002\u7528\u4e8e\u9700\u8981\u6279\u91cf\u5904\u7406\u7684\u573a\u666f\uff0c\u5982\u6587\u4ef6\u8f6c\u6362\u3001\u6570\u636e\u5904\u7406\u7b49\u3002</p>"},{"location":"zh/interactive_cli/#_4","title":"\u4ea4\u4e92\u8bed\u8a00","text":"<p>\u4e0e\u547d\u4ee4\u884c\u5e94\u7528\u7edf\u4e00\u4f7f\u7528\u7ec8\u7aef\u8bed\u6cd5\u4e0d\u540c\uff0c\u5e02\u9762\u4e0a\u7684\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u5f80\u5f80\u4f1a\u4f7f\u7528\u4e0d\u540c\u7684\u8bed\u8a00\u6765\u5b9e\u73b0\u3002\u5982Python\u7684REPL\u5c31\u76f4\u63a5\u4f7f\u7528Python\u8bed\u8a00\u8fdb\u884c\u4ea4\u4e92\uff1bgdb\u5219\u6709\u4e00\u5957\u81ea\u5b9a\u4e49\u7684\u4ea4\u4e92\u8bed\u8a00\uff0c\u7528\u4e8e\u8c03\u8bd5\u7a0b\u5e8f\uff1b\u6570\u636e\u5e93\u5ba2\u6237\u7aef\u4e00\u822c\u5219\u4f7f\u7528SQL\u8bed\u8a00\u8fdb\u884c\u4ea4\u4e92\u3002</p> <pre><code>&gt;&gt;&gt; def factorial(n: int) -&gt; int:\n...     if n &lt; 2:\n...         return 1\n...     return n * factorial(n - 1)\n...\n&gt;&gt;&gt; factorial(5)\n120\n</code></pre> <p>\u8fd8\u6709\u4e00\u90e8\u5206\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u5219\u4f7f\u7528\u4eff\u7ec8\u7aef\u8bed\u8a00\u8fdb\u884c\u7528\u6237\u4ea4\u4e92\uff0c\u5982sftp\u3002\u8fd9\u79cd\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u7a0b\u5e8f\u5f62\u5f0f\u4e0a\u7c7b\u4f3c\u4e8e\u7ec8\u7aef\uff0c\u4f46\u4f7f\u7528\u4e0d\u4e0e\u7ec8\u7aef\u901a\u7528\u7684\u81ea\u5b9a\u4e49\u547d\u4ee4\u3002\u8fd9\u79cd\u65b9\u5f0f\u66f4\u7b26\u5408\u4e00\u822c\u7684\u4f7f\u7528\u4e60\u60ef\uff0c\u51cf\u8f7b\u4e86\u7528\u6237\u5728\u8bed\u6cd5\u7406\u89e3\u65b9\u9762\u7684\u4e0a\u624b\u96be\u5ea6\u3002</p> <pre><code>sftp&gt; ?\nAvailable commands:\nbye                                Quit sftp\ncd path                            Change remote directory to 'path'\nchgrp [-h] grp path                Change group of file 'path' to 'grp'\nchmod [-h] mode path               Change permissions of file 'path' to 'mode'\nchown [-h] own path                Change owner of file 'path' to 'own'\ncopy oldpath newpath               Copy remote file\ncp oldpath newpath                 Copy remote file\ndf [-hi] [path]                    Display statistics for current directory or\n                                   filesystem containing 'path'\nexit                               Quit sftp\nget [-afpR] remote [local]         Download file\nhelp                               Display this help text\nlcd path                           Change local directory to 'path'\nlls [ls-options [path]]            Display local directory listing\nlmkdir path                        Create local directory\nln [-s] oldpath newpath            Link remote file (-s for symlink)\nlpwd                               Print local working directory\nls [-1afhlnrSt] [path]             Display remote directory listing\nlumask umask                       Set local umask to 'umask'\nmkdir path                         Create remote directory\nprogress                           Toggle display of progress meter\nput [-afpR] local [remote]         Upload file\npwd                                Display remote working directory\nquit                               Quit sftp\nreget [-fpR] remote [local]        Resume download file\nrename oldpath newpath             Rename remote file\nreput [-fpR] local [remote]        Resume upload file\nrm path                            Delete remote file\nrmdir path                         Remove remote directory\nsymlink oldpath newpath            Symlink remote file\nversion                            Show SFTP version\n!command                           Execute 'command' in local shell\n!                                  Escape to local shell\n?                                  Synonym for help\n</code></pre>"},{"location":"zh/interactive_cli/#_5","title":"\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u7684\u5f00\u53d1","text":"<p>\u5bf9\u4e8e\u4f7f\u7528\u81ea\u5b9a\u4e49\u4ea4\u4e92\u8bed\u8a00\u7684\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u6765\u8bf4\uff0c\u4ea4\u4e92\u5f0f\u8bed\u8a00\u5f80\u5f80\u9700\u8981\u5f00\u53d1\u8005\u81ea\u884c\u8fdb\u884c\u8bed\u6cd5\u89e3\u6790\uff0c\u5f00\u53d1\u96be\u5ea6\u8f83\u9ad8\u3002\u800c\u4f7f\u7528\u4eff\u7ec8\u7aef\u4ea4\u4e92\u8bed\u8a00\u7684\u5e94\u7528\u6709\u7740\u66f4\u591a\u7684\u73b0\u6709\u5de5\u5177\uff0c\u5f00\u53d1\u96be\u5ea6\u8f83\u4f4e\u3002\u8fd9\u4e5f\u662f<code>ptcmd</code>\u652f\u6301\u7684\u65b9\u5411\u3002</p> <p>\u65e2\u7136\u4f7f\u7528\u4e86\u4eff\u7ec8\u7aef\u4ea4\u4e92\u8bed\u8a00\uff0c\u90a3\u4e48\u80fd\u5426\u76f4\u63a5\u590d\u7528\u547d\u4ee4\u884c\u5e94\u7528\u7684\u5f00\u53d1\u5de5\u5177\u94fe\u5462\uff1f\u6beb\u65e0\u7591\u95ee\uff0c\u547d\u4ee4\u884c\u7684\u5f00\u53d1\u5de5\u5177\u94fe\u7684\u975e\u5e38\u5b8c\u5907\u7684\uff0c\u6709\u5f88\u591a\u7684Python\u5e93\uff0c\u4ece\u6807\u51c6\u5e93\u4e2d\u7684<code>argparse</code>\uff0c\u518d\u5230\u4e0a\u5c42\u7684<code>click</code>\u3001<code>typer</code>\u7b49\u7b2c\u4e09\u65b9\u5e93\u90fd\u5141\u8bb8\u5f00\u53d1\u8005\u5feb\u901f\u642d\u5efa\u590d\u6742\u7684\u5305\u542b\u591a\u5c42\u5b50\u547d\u4ee4\u7684\u547d\u4ee4\u884c\u5e94\u7528\u3002\u4f46\u76f4\u63a5\u4f7f\u7528\u547d\u4ee4\u884c\u5f00\u53d1\u5de5\u5177\u94fe\u5f00\u53d1\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u5b58\u5728\u8bf8\u591a\u95ee\u9898\u3002</p> <ol> <li>\u547d\u4ee4\u884c\u5e94\u7528\u5f80\u5f80\u88ab\u8bbe\u8ba1\u4e3a\u5728\u53d1\u73b0\u9519\u8bef\u65f6\u76f4\u63a5\u9000\u51fa\uff0c\u8fd9\u4e0d\u7b26\u5408\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u7684\u9700\u6c42\u3002\u8fd9\u79cd\u884c\u4e3a\u6839\u690d\u4e8e\u5b9e\u73b0\u5e95\u5c42\uff0c\u96be\u4ee5\u901a\u8fc7\u914d\u7f6e\u66f4\u6539\u3002</li> <li>\u547d\u4ee4\u884c\u5e94\u7528\u7684\u8865\u5168\u673a\u5236\u90fd\u662f\u9488\u5bf9\u4e8e\u7ec8\u7aef\u73af\u5883\u5f00\u53d1\uff0c\u65e0\u6cd5\u5e94\u7528\u5230\u4ea4\u4e92\u5f0f\u73af\u5883\u4e2d\u3002</li> </ol> <p>\u5bf9\u4e8e\u4ea4\u4e92\u5f0f\u5e94\u7528\uff0cPython\u5b9e\u9645\u4e0a\u4e5f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6807\u51c6\u5e93<code>cmd</code>\uff0c\u5141\u8bb8\u5f00\u53d1\u8005\u901a\u8fc7\u5b9a\u4e49\u4e00\u4e2a\u7c7b\u7ee7\u627f<code>cmd.Cmd</code>\u7c7b\uff0c\u5e76\u5b9e\u73b0\u76f8\u5e94\u7684\u65b9\u6cd5\uff0c\u6765\u521b\u5efa\u4e00\u4e2a\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u3002</p> <pre><code>import sys\nimport cmd\n\nclass MyCmd(cmd.Cmd):\n    def do_hello(self, args: str) -&gt; None:\n        print(\"Hello, world!\")\n\nif __name__ == '__main__':\n    sys.exit(MyCmd().cmdloop())\n</code></pre> <p>\u7136\u800c\uff0c<code>cmd</code>\u5e93\u9700\u8981\u7528\u6237\u624b\u52a8\u8fdb\u884c\u53c2\u6570\u89e3\u6790\uff0c\u4e0d\u652f\u6301\u591a\u7ea7\u5b50\u547d\u4ee4\uff0c\u4ec5\u652f\u6301\u5bf9\u547d\u4ee4\u540d\u8fdb\u884c\u8865\u5168\u3002\u8fd9\u5bf9\u4e8e\u73b0\u4ee3\u7684\u4ea4\u4e92\u5f0f\u5e94\u7528\u6765\u8bf4\u5e76\u4e0d\u8db3\u591f\u3002\u7b2c\u4e09\u65b9\u5e93<code>cmd2</code>\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u89e3\u51b3\u4e86\u8fd9\u4e9b\u95ee\u9898\uff0c\u8fd9\u662f\u4e00\u4e2a<code>cmd</code>\u5e93\u7684\u6269\u5c55\uff0c\u5728\u517c\u5bb9<code>cmd</code>\u5e93\u7684\u540c\u65f6\uff0c\u63d0\u4f9b\u4e86\u66f4\u4e30\u5bcc\u7684\u529f\u80fd\uff0c\u5982\u5b8c\u6574\u7684\u901a\u8fc7<code>ArgumentParser</code>\u7684\u81ea\u52a8\u547d\u4ee4\u8865\u5168\u3002</p> <p><code>cmd2</code>\u57fa\u672c\u5df2\u7ecf\u53ef\u4ee5\u6ee1\u8db3\u89c9\u5927\u591a\u6570\u7684\u4ea4\u4e92\u5f0f\u5e94\u7528\u9700\u6c42\uff0c\u4f46\u4ecd\u7136\u5b58\u5728\u4e00\u4e9b\u95ee\u9898\uff1a</p> <ol> <li>\u5bf9\u5b50\u547d\u4ee4\u7684\u652f\u6301\u4e0d\u591f\u597d\uff0c\u4e0d\u652f\u6301\u4efb\u610f\u591a\u7ea7\u5b50\u547d\u4ee4\u3002</li> <li>\u547d\u4ee4\u7684\u53c2\u6570\u89e3\u6790\u4e0d\u591f\u667a\u80fd\uff0c\u9700\u8981\u624b\u52a8\u6784\u9020<code>ArgumentParser</code>\uff0c\u8fd9\u9020\u6210\u4e86\u5927\u91cf\u6837\u677f\u4ee3\u7801\u3002</li> <li>\u5bcc\u6587\u672c\u652f\u6301\u4e0d\u591f\u597d\uff0c\u9700\u8981\u4f7f\u7528\u5e93\u81ea\u5b9a\u4e49\u7684\u6784\u9020\u65b9\u5f0f\uff0c\u4e0d\u652f\u6301\u66f4\u52a0\u901a\u7528\u7684<code>rich</code>\u5e93\uff08\u76ee\u524d\u57283.X\u7248\u672c\u5df2\u7ecf\u8fc1\u79fb\u5230<code>rich</code>\uff09</li> </ol> <p>\u56e0\u6b64\uff0c<code>ptcmd</code>\u8bde\u751f\u4e86\uff0c\u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u4e86\u66f4\u52a0\u73b0\u4ee3\u5316\u7684\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u6784\u5efa\u65b9\u6848\u3002</p>"},{"location":"zh/start/","title":"\u5feb\u901f\u5f00\u59cb","text":""},{"location":"zh/start/#_2","title":"\u5b89\u88c5","text":"<p>\u4ecePypi\u5b89\u88c5\uff08\u63a8\u8350\uff09\uff1a</p> <pre><code>pip install ptcmd\n</code></pre> <p>\u6216\u4ece\u6e90\u7801\u5b89\u88c5\uff1a</p> <pre><code>git clone https://github.com/Visecy/ptcmd.git\ncd ptcmd\nmake install\n</code></pre> <p>\u5982\u679c\u5e0c\u671b\u8fd0\u884c\u5355\u5143\u6d4b\u8bd5\uff0c\u53ef\u4ee5\u4f7f\u7528\uff1a</p> <pre><code>make develop test\n</code></pre> <p>\u5982\u679c\u60f3\u5728\u672c\u5730\u6784\u5efa\u6587\u6863\uff0c\u53ef\u4ee5\u4f7f\u7528\uff1a <pre><code>make develop docs\n</code></pre></p>"},{"location":"zh/start/#_3","title":"\u57fa\u672c\u5e94\u7528\u7ed3\u6784","text":"<p>ptcmd\u5e94\u7528\u57fa\u672c\u90fd\u9075\u5faa\u4e00\u4e2a\u4e00\u81f4\u7684\u6a21\u5f0f\uff1a\u7ee7\u627f <code>Cmd</code> \u7c7b\uff0c\u5e76\u4f7f\u7528 <code>do_</code> \u524d\u7f00\u7ea6\u5b9a\u5b9a\u4e49\u547d\u4ee4\u65b9\u6cd5\uff0c\u6700\u540e\u521b\u5efa\u5b9e\u4f8b\u5e76\u8c03\u7528<code>cmdloop()</code>\u65b9\u6cd5\u542f\u52a8\u4ea4\u4e92\u3002</p>"},{"location":"zh/start/#_4","title":"\u521b\u5efa\u7b2c\u4e00\u4e2a\u5e94\u7528","text":"<p>\u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a\u6700\u7b80\u5355\u7684\u5e94\u7528\u5f00\u59cb\uff1a</p> <pre><code>import sys\nfrom ptcmd import Cmd\n\nclass MyApp(Cmd):\n    def do_hello(self, argv: list[str]) -&gt; None:\n        \"\"\"Hello World!\"\"\"\n        if argv:\n            name = argv[0]\n        else:\n            name = \"World\"\n        self.poutput(f\"Hello, {name}!\")\n\nif __name__ == \"__main__\":\n    sys.exit(MyApp().cmdloop())\n</code></pre> <p>\u6211\u4eec\u5b9a\u4e49\u4e86\u4e00\u4e2a\u540d\u4e3a<code>MyApp</code>\u7684\u7c7b\uff0c\u7ee7\u627f\u81ea<code>Cmd</code>\uff0c\u5728\u7c7b\u4e2d\u5b9a\u4e49\u4e86\u552f\u4e00\u7684\u4e00\u4e2a\u547d\u4ee4<code>hello</code>\u3002\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u8fd0\u884c\u8fd9\u4e2a\u811a\u672c\uff1a</p> <pre><code>(Cmd) hello\nHello, World!\n(Cmd) hello Alice\nHello, Alice!\n(Cmd) exit\n</code></pre> <p>\u8f93\u5165<code>hello</code>\u547d\u4ee4\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f97\u5230\u6211\u4eec\u60f3\u8981\u7684\u8f93\u51fa\u7ed3\u679c\uff0c\u6700\u540e\u522b\u5fd8\u8bb0\u8f93\u5165<code>exit</code>\u547d\u4ee4\u9000\u51fa\u7a0b\u5e8f\u3002</p>"},{"location":"zh/start/#_5","title":"\u4f7f\u7528\u58f0\u660e\u5f0f\u53c2\u6570\u89e3\u6790","text":"<p>\u4ee5\u4e0a\u7684\u793a\u4f8b\u5176\u5b9e\u6709\u4e00\u70b9\u5c0f\u95ee\u9898\uff0c\u5f53\u4f20\u5165\u591a\u4e2a\u53c2\u6570\u65f6\uff0c\u547d\u4ee4\u4f1a\u76f4\u63a5\u5ffd\u7565\u540e\u9762\u7684\u53c2\u6570\u3002\u8fd9\u5e76\u4e0d\u662f\u4e00\u4e2a\u597d\u7684\u5b9e\u8df5\u3002\u5728\u51fd\u6570\u4e2d\u6dfb\u52a0\u4e00\u4e9b\u5224\u65ad\u6216\u8005\u4f7f\u7528<code>argparse</code>\u6765\u5904\u7406\u8fd9\u79cd\u60c5\u51b5\uff0c\u4e0d\u8fc7\u8fd9\u4e9b\u65b9\u5f0f\u90fd\u4e0d\u591f\u7b80\u6d01\uff0c\u4f1a\u4ea7\u751f\u5927\u91cf\u7684\u6837\u677f\u4ee3\u7801\u3002</p> <p><code>ptcmd</code>\u63d0\u4f9b\u4e86\u4e00\u79cd\u58f0\u660e\u5f0f\u53c2\u6570\u89e3\u6790\u7684\u65b9\u5f0f\uff0c\u53ef\u4ee5\u901a\u8fc7\u5206\u6790\u51fd\u6570\u7684\u7b7e\u540d\u4fe1\u606f\uff0c\u81ea\u52a8\u8fdb\u884c\u53c2\u6570\u89e3\u6790\u3002\u8fd9\u9700\u8981\u4f7f\u7528<code>@auto_argument</code>\u88c5\u9970\u5668\u6765\u88c5\u9970\u547d\u4ee4\u65b9\u6cd5\uff1a</p> <pre><code>import sys\nfrom ptcmd import Cmd, auto_argument\n\nclass MyApp(Cmd):\n    @auto_argument\n    def do_hello(self, name: str = \"World\") -&gt; None:\n        \"\"\"Hello World!\"\"\"\n        self.poutput(f\"Hello, {name}!\")\n\nif __name__ == \"__main__\":\n    sys.exit(MyApp().cmdloop())\n</code></pre> <p>\u73b0\u5728\u6211\u4eec\u901a\u8fc7\u66f4\u52a0\u7b80\u77ed\u7684\u4ee3\u7801\u5b9e\u73b0\u4e86\u529f\u80fd\u66f4\u52a0\u5b8c\u5584\u7684\u547d\u4ee4\u3002\u73b0\u5728\u4f60\u53ef\u4ee5\u50cf\u4f7f\u7528\u547d\u4ee4\u884c\u7a0b\u5e8f\u4e00\u6837\uff0c\u4f7f\u7528<code>-h/--help</code>\u53c2\u6570\u6765\u83b7\u53d6\u547d\u4ee4\u4fe1\u606f\uff1a</p> <pre><code>(Cmd) hello\nHello, World!\n(Cmd) hello Alice\nHello, Alice!\n(Cmd) hello -h\nUsage: hello [-h] [name]\n\nHello World!\n\nPositional Arguments:\n  name\n\nOptional Arguments:\n  -h, --help  show this help message and exit\n</code></pre>"},{"location":"zh/start/#_6","title":"\u4e0b\u4e00\u6b65\u8be5\u505a\u4ec0\u4e48","text":"<ul> <li>\u89c2\u770b\u7528\u6237\u6307\u5357\u4ee5\u83b7\u53d6\u66f4\u8be6\u7ec6\u7684\u4f7f\u7528\u8bf4\u660e\u3002</li> <li>\u89c2\u770b\u793a\u4f8b\u4ee5\u83b7\u53d6\u66f4\u591a\u793a\u4f8b\u3002</li> <li>\u89c2\u770bAPI \u53c2\u8003\u4ee5\u83b7\u53d6\u8be6\u7ec6\u7684 API \u5b9a\u4e49\u3002</li> </ul>"},{"location":"zh/api/","title":"API \u53c2\u8003","text":"<p>API\u6587\u6863\u7531\u4ee3\u7801\u81ea\u52a8\u751f\u6210\uff0c\u4e0d\u63d0\u4f9b\u7ffb\u8bd1</p> <ul> <li>ptcmd.argument</li> <li>ptcmd.info</li> <li>ptcmd.command</li> <li>ptcmd.completer</li> <li>ptcmd.core</li> </ul>"},{"location":"zh/user_guide/","title":"\u7528\u6237\u6307\u5357","text":"<p>\u7528\u6237\u6307\u5357\u4e3b\u8981\u4ecb\u7ecd<code>ptcmd</code>\u7684\u5177\u4f53\u4f7f\u7528\u8bf4\u660e\uff0c\u6d89\u53ca\u90e8\u5206\u5e95\u5c42\u5b9e\u73b0\u7ec6\u8282\u3002</p>"},{"location":"zh/user_guide/#_2","title":"\u6587\u6863\u7ed3\u6784","text":"<ul> <li>\u6838\u5fc3\u6982\u5ff5: \u4ecb\u7ecd ptcmd \u7684\u57fa\u7840\u6784\u5efa\u6a21\u5757\uff0c\u5305\u62ec\u5e94\u7528\u7a0b\u5e8f\u4e3b\u7ed3\u6784\u548c\u5173\u952e\u7ec4\u4ef6</li> <li>\u53c2\u6570\u5904\u7406: \u8be6\u7ec6\u8bf4\u660e\u547d\u4ee4\u53c2\u6570\u7684\u5b9a\u4e49\u3001\u9a8c\u8bc1\u548c\u7c7b\u578b\u8f6c\u6362\u673a\u5236</li> <li>\u547d\u4ee4\u5b9e\u73b0: \u6df1\u5165\u8bb2\u89e3\u547d\u4ee4\u5b9a\u4e49\u3001\u6267\u884c\u6d41\u7a0b\u548c\u9ad8\u7ea7\u547d\u4ee4\u6a21\u5f0f</li> </ul>"},{"location":"zh/user_guide/argument/","title":"\u53c2\u6570\u89e3\u6790","text":"<p>\u53c2\u6570\u89e3\u6790\u7cfb\u7edf\u63d0\u4f9b\u4e86\u4ece\u51fd\u6570\u7b7e\u540d\u6784\u5efa<code>ArgumentParser</code>\u7684\u529f\u80fd\u3002\u8fd9\u662f\u4e00\u4e2a\u76f8\u5bf9\u72ec\u7acb\u7684\u7ec4\u4ef6\uff0c\u901a\u8fc7\u4e0e\u547d\u4ee4\u7ec4\u4ef6\u7c7b<code>Command</code>\u96c6\u6210\u6765\u8fdb\u5165<code>ptcmd</code>\u6846\u67b6\u3002</p>"},{"location":"zh/user_guide/argument/#_2","title":"\u57fa\u672c\u793a\u4f8b","text":"<p>\u4f7f\u7528<code>@auto_argument</code>\u88c5\u9970\u5668\u662f\u6700\u7b80\u5355\u7684\u58f0\u660e\u5f0f\u53c2\u6570\u89e3\u6790\u65b9\u5f0f\u3002\u5b83\u4f1a\u81ea\u52a8\u5206\u6790\u51fd\u6570\u7684\u53c2\u6570\u7b7e\u540d\uff0c\u5e76\u521b\u5efa\u76f8\u5e94\u7684<code>ArgumentParser</code>\u5b9e\u4f8b\uff1a</p> <pre><code>from ptcmd import Cmd, auto_argument\n\nclass MyApp(Cmd):\n    @auto_argument\n    def do_hello(self, name: str = \"World\") -&gt; None:\n        \"\"\"Hello World!\"\"\"\n        self.poutput(f\"Hello, {name}!\")\n</code></pre> <p>\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c<code>name</code>\u53c2\u6570\u4f1a\u81ea\u52a8\u8f6c\u6362\u4e3a\u4e00\u4e2a\u53ef\u9009\u7684\u4f4d\u7f6e\u53c2\u6570\uff0c\u9ed8\u8ba4\u503c\u4e3a\"World\"\u3002</p>"},{"location":"zh/user_guide/argument/#argument","title":"Argument\u7c7b","text":"<p><code>Argument</code> \u662f\u53c2\u6570\u89e3\u6790\u7cfb\u7edf\u7684\u6838\u5fc3\u7c7b\uff0c\u7528\u4e8e\u4ee5\u58f0\u660e\u5f0f\u65b9\u5f0f\u5b9a\u4e49\u547d\u4ee4\u884c\u53c2\u6570\u3002\u5b83\u5c01\u88c5\u4e86 <code>argparse</code> \u7684\u53c2\u6570\u914d\u7f6e\uff0c\u63d0\u4f9b\u66f4 Pythonic \u7684\u63a5\u53e3\u3002</p>"},{"location":"zh/user_guide/argument/#_3","title":"\u57fa\u672c\u7528\u6cd5","text":"<p>\u53ef\u4ee5\u76f4\u63a5\u5b9e\u4f8b\u5316 <code>Argument</code> \u6765\u5b9a\u4e49\u53c2\u6570\uff1a</p> <pre><code>from ptcmd import Argument\n\n# \u521b\u5efa\u4e00\u4e2a\u7b80\u5355\u7684\u5b57\u7b26\u4e32\u53c2\u6570\nfile_arg = Argument(\n    \"--file\", \n    type=str,\n    help=\"\u8f93\u5165\u6587\u4ef6\u8def\u5f84\"\n)\n\n# \u521b\u5efa\u4e00\u4e2a\u5e03\u5c14\u6807\u5fd7\u53c2\u6570\nverbose_arg = Argument(\n    \"-v\", \"--verbose\",\n    action=\"store_true\",\n    help=\"\u542f\u7528\u8be6\u7ec6\u8f93\u51fa\"\n)\n</code></pre>"},{"location":"zh/user_guide/argument/#_4","title":"\u53c2\u6570\u914d\u7f6e","text":"<p><code>Argument</code> \u652f\u6301\u6240\u6709\u6807\u51c6 <code>argparse</code> \u53c2\u6570\u914d\u7f6e\uff0c\u5e38\u7528\u53c2\u6570\u5982\u4e0b\uff1a</p> \u53c2\u6570 \u63cf\u8ff0 \u793a\u4f8b <code>action</code> \u6307\u5b9a\u53c2\u6570\u52a8\u4f5c <code>action=\"store_true\"</code> <code>nargs</code> \u53c2\u6570\u6570\u91cf <code>nargs='*'</code> <code>const</code> \u4e0e <code>nargs</code> \u6216 <code>action</code> \u914d\u5408\u4f7f\u7528\u7684\u5e38\u91cf\u503c <code>const=\"value\"</code> <code>default</code> \u9ed8\u8ba4\u503c <code>default=0</code> <code>type</code> \u53c2\u6570\u7c7b\u578b\u8f6c\u6362\u51fd\u6570 <code>type=int</code> <code>choices</code> \u5141\u8bb8\u7684\u53c2\u6570\u503c\u5217\u8868 <code>choices=[\"a\", \"b\"]</code> <code>required</code> \u662f\u5426\u5fc5\u9700 <code>required=True</code> <code>help</code> \u5e2e\u52a9\u6587\u672c <code>help=\"\u8f93\u5165\u6587\u4ef6\u8def\u5f84\"</code> <code>metavar</code> \u5728\u5e2e\u52a9\u6d88\u606f\u4e2d\u663e\u793a\u7684\u53c2\u6570\u540d\u79f0 <code>metavar=\"FILE\"</code> <code>dest</code> \u5b58\u50a8\u53c2\u6570\u503c\u7684\u76ee\u6807\u5c5e\u6027\u540d <code>dest=\"output_file\"</code> <code>version</code> \u4e0e <code>action=\"version\"</code> \u914d\u5408\u4f7f\u7528\u7684\u7248\u672c\u53f7 <code>version=\"1.0.0\"</code> <p>\u4f8b\u5982\uff0c\u5b9a\u4e49\u4e00\u4e2a\u9700\u8981\u591a\u4e2a\u8f93\u5165\u6587\u4ef6\u7684\u53c2\u6570\uff1a</p> <pre><code>files: Arg[\n    list,\n    \"--files\",\n    {\"nargs\": \"*\", \"type\": str, \"help\": \"\u8f93\u5165\u6587\u4ef6\u5217\u8868\"}\n]\n</code></pre>"},{"location":"zh/user_guide/argument/#arg","title":"\u4f7f\u7528Arg\u7c7b\u578b\u6ce8\u89e3","text":"<p>\u5bf9\u4e8e\u66f4\u590d\u6742\u7684\u53c2\u6570\u5b9a\u4e49\uff0c\u53ef\u4ee5\u4f7f\u7528<code>Arg</code>\u7c7b\u578b\u63d0\u793a\u3002<code>Arg</code>\u5141\u8bb8\u6307\u5b9a\u53c2\u6570\u7684\u6807\u5fd7\u3001\u5e2e\u52a9\u6587\u672c\u548c\u5176\u4ed6\u5c5e\u6027\uff1a</p> <pre><code>from ptcmd import Cmd, Arg, auto_argument\n\nclass MathApp(Cmd):\n    @auto_argument\n    def do_add(\n        self, \n        x: float, \n        y: float,\n        *,\n        verbose: Arg[bool, \"-v\", \"--verbose\", {\"help\": \"\u8be6\u7ec6\u8f93\u51fa\"}] = False\n    ) -&gt; None:\n        \"\"\"\u4e24\u6570\u76f8\u52a0\"\"\"\n        result = x + y\n        if verbose:\n            self.poutput(f\"{x} + {y} = {result}\")\n        else:\n            self.poutput(result)\n</code></pre> <p><code>Arg</code>\u7684\u8bed\u6cd5\u683c\u5f0f\u4e3a\uff1a<code>Arg[\u7c7b\u578b, \u53c2\u6570\u6807\u5fd7..., {\u53c2\u6570\u5c5e\u6027}]</code></p> <ul> <li>\u7c7b\u578b\uff1a\u53c2\u6570\u7684\u6570\u636e\u7c7b\u578b\uff08\u5982<code>str</code>\u3001<code>int</code>\u3001<code>float</code>\u3001<code>bool</code>\u7b49\uff09</li> <li>\u53c2\u6570\u6807\u5fd7\uff1a\u53c2\u6570\u7684\u547d\u4ee4\u884c\u6807\u5fd7\uff08\u5982<code>\"-v\"</code>\u3001<code>\"--verbose\"</code>\uff09</li> <li>\u53c2\u6570\u5c5e\u6027\uff1a\u4e00\u4e2a\u5b57\u5178\uff0c\u5305\u542b\u53c2\u6570\u7684\u5176\u4ed6\u5c5e\u6027\uff08\u5982<code>help</code>\u3001<code>choices</code>\u7b49\uff09\uff0c\u4e5f\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a<code>Argument</code>\u4f5c\u4e3a\u5c5e\u6027\u3002</li> </ul> <p>Note</p> <p><code>Arg</code>\u5b9e\u9645\u4e0a\u662f\u9002\u7528\u4e8e\u7c7b\u578b\u68c0\u67e5\u5668\u7684\u7b80\u5355\u8f6c\u6362\uff0c\u8fd0\u884c\u65f6\u4e0e<code>Argument</code>\u7c7b\u5b8c\u5168\u7b49\u4ef7\u3002\u4f46\u901a\u5e38\u63a8\u8350<code>Arg</code>\u4ec5\u7528\u4e8e\u7c7b\u578b\u6ce8\u89e3</p>"},{"location":"zh/user_guide/argument/#annotatedargument","title":"\u4f7f\u7528Annotated\u548cArgument\u7c7b\u578b\u6ce8\u89e3","text":"<p>\u5982\u679c\u5e0c\u671b\u66f4\u4e25\u683c\u7684\u9075\u7167\u4ee3\u7801\u98ce\u683c\u68c0\u67e5\u5668\uff0c\u53ef\u4ee5\u4f7f\u7528\u6807\u51c6\u7684<code>Annotated</code>\u548c<code>Argument</code>\u4ee5\u89c4\u907f<code>Arg</code>\u7684\u8bed\u6cd5\u62a5\u9519\uff1a</p> <pre><code>from typing import Annotated\nfrom ptcmd import Cmd, Argument, auto_argument\n\nclass MathApp(Cmd):\n    @auto_argument\n    def do_add(\n        self, \n        x: float, \n        y: float,\n        *,\n        verbose: Annotated[bool, Argument(\"-v\", \"--verbose\", action=\"store_true\")] = False\n    ) -&gt; None:\n        \"\"\"\u4e24\u6570\u76f8\u52a0\"\"\"\n        result = x + y\n        if verbose:\n            self.poutput(f\"{x} + {y} = {result}\")\n        else:\n            self.poutput(result)\n</code></pre> <p>\u4f46\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u5b9a\u4e49\u7684\u53c2\u6570\u65e0\u6cd5\u83b7\u5f97\u53c2\u6570\u5b57\u6bb5\u8865\u5168\uff0c\u9700\u8981\u81ea\u884c\u5728<code>Argument</code>\u6307\u5b9a\u6240\u6709\u9700\u8981\u7684\u5b57\u6bb5\u3002</p>"},{"location":"zh/user_guide/argument/#_5","title":"\u53c2\u6570\u5ffd\u7565","text":"<p>\u5f53\u67d0\u4e9b\u53c2\u6570\u4e0d\u9700\u8981\u51fa\u73b0\u5728\u547d\u4ee4\u884c\u754c\u9762\u65f6\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>IgnoreArg</code> \u7c7b\u578b\u6765\u6807\u8bb0\u8be5\u53c2\u6570\u5e94\u88ab\u5ffd\u7565\uff1a</p> <pre><code>from ptcmd import Cmd, IgnoreArg, auto_argument\n\nclass App(Cmd):\n    @auto_argument\n    def do_process(\n        self,\n        input: str,\n        internal_state: IgnoreArg[dict] = {}\n    ) -&gt; None:\n        \"\"\"\u5904\u7406\u8f93\u5165\u6570\u636e\uff0cinternal_state \u4ec5\u7528\u4e8e\u5185\u90e8\u72b6\u6001\u7ba1\u7406\"\"\"\n        # internal_state \u4e0d\u4f1a\u51fa\u73b0\u5728\u547d\u4ee4\u884c\u53c2\u6570\u4e2d\n        self.poutput(f\"Processing {input}\")\n</code></pre> <p>\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c<code>internal_state</code> \u53c2\u6570\u5c06\u88ab\u5b8c\u5168\u5ffd\u7565\uff0c\u4e0d\u4f1a\u6dfb\u52a0\u5230\u547d\u4ee4\u884c\u89e3\u6790\u5668\u4e2d\u3002</p>"},{"location":"zh/user_guide/argument/#_6","title":"\u53c2\u6570\u89e3\u6790","text":"<p><code>ptcmd</code>\u4f1a\u6839\u636e\u53c2\u6570\u7684\u7c7b\u578b\u548c\u4f4d\u7f6e\u81ea\u52a8\u63a8\u65ad\u53c2\u6570\u7684\u884c\u4e3a\uff1a</p> <ol> <li>\u4f4d\u7f6e\u53c2\u6570\uff1a\u51fd\u6570\u7684\u4f4d\u7f6e\u53c2\u6570\u4f1a\u8f6c\u6362\u4e3a\u547d\u4ee4\u884c\u7684\u4f4d\u7f6e\u53c2\u6570</li> <li>\u53ef\u9009\u53c2\u6570\uff1a\u4f7f\u7528<code>*</code>\u5206\u9694\u7684\u5173\u952e\u5b57\u53c2\u6570\u4f1a\u8f6c\u6362\u4e3a\u53ef\u9009\u53c2\u6570</li> <li>\u5e03\u5c14\u53c2\u6570\uff1a\u7c7b\u578b\u4e3a<code>bool</code>\u7684\u53c2\u6570\u4f1a\u81ea\u52a8\u8f6c\u6362\u4e3a\u6807\u5fd7\u53c2\u6570\uff08<code>store_true</code>\u6216<code>store_false</code>\uff09</li> <li>\u9ed8\u8ba4\u503c\uff1a\u53c2\u6570\u7684\u9ed8\u8ba4\u503c\u4f1a\u4f20\u9012\u7ed9<code>ArgumentParser</code></li> </ol>"},{"location":"zh/user_guide/argument/#_7","title":"\u81ea\u52a8\u63a8\u65ad","text":"<p>\u53c2\u6570\u89e3\u6790\u53ef\u4ee5\u6839\u636e\u7c7b\u578b\u6ce8\u89e3\u548c\u53c2\u6570\u7279\u5f81\u81ea\u52a8\u63a8\u65ad\u5408\u9002\u7684 <code>argparse</code> \u914d\u7f6e\uff0c\u51cf\u5c11\u624b\u52a8\u914d\u7f6e\u3002\u4ee5\u4e0b\u662f\u5173\u952e\u7684\u81ea\u52a8\u63a8\u65ad\u89c4\u5219\uff1a</p>"},{"location":"zh/user_guide/argument/#_8","title":"\u5e03\u5c14\u7c7b\u578b\u81ea\u52a8\u8f6c\u6362","text":"<p>\u7cfb\u7edf\u4f1a\u6839\u636e\u5e03\u5c14\u53c2\u6570\u7684\u9ed8\u8ba4\u503c\u81ea\u52a8\u9009\u62e9 <code>store_true</code> \u6216 <code>store_false</code> \u52a8\u4f5c\uff1a</p> <pre><code># \u9ed8\u8ba4\u503c\u4e3a False -&gt; \u81ea\u52a8\u4f7f\u7528 store_true\nverbose: Arg[bool] = False  \n# \u751f\u6210: parser.add_argument(\"--verbose\", action=\"store_true\")\n\n# \u9ed8\u8ba4\u503c\u4e3a True -&gt; \u81ea\u52a8\u4f7f\u7528 store_false\nenabled: Arg[bool] = True   \n# \u751f\u6210: parser.add_argument(\"--enabled\", action=\"store_false\")\n\n# \u4e5f\u53ef\u4ee5\u663e\u5f0f\u6307\u5b9a\u6807\u5fd7\ndebug: Arg[bool, \"-d\", \"--debug\"] = False\n# \u751f\u6210: parser.add_argument(\"-d\", \"--debug\", action=\"store_true\")\n</code></pre>"},{"location":"zh/user_guide/argument/#_9","title":"\u4f4d\u7f6e\u53c2\u6570\u4e0e\u5173\u952e\u5b57\u53c2\u6570\u7684\u81ea\u52a8\u5904\u7406","text":"<p>\u7cfb\u7edf\u4f1a\u6839\u636e\u53c2\u6570\u5728\u51fd\u6570\u7b7e\u540d\u4e2d\u7684\u4f4d\u7f6e\u81ea\u52a8\u51b3\u5b9a\u662f\u4f4d\u7f6e\u53c2\u6570\u8fd8\u662f\u53ef\u9009\u53c2\u6570\uff1a</p> <pre><code>@auto_argument\ndef do_process(\n    self,\n    input_file: str,      # \u4f4d\u7f6e\u53c2\u6570\uff08\u65e0\u9ed8\u8ba4\u503c\uff09\n    output: str = \"out\",  # \u4f4d\u7f6e\u53c2\u6570\uff08\u5e26\u9ed8\u8ba4\u503c\uff09\n    *,\n    verbose: bool = False # \u5173\u952e\u5b57\u53c2\u6570 -&gt; \u53ef\u9009\u53c2\u6570\n) -&gt; None:\n    pass\n</code></pre> <ul> <li>\u4f4d\u7f6e\u53c2\u6570\uff1a\u51fd\u6570\u7b7e\u540d\u4e2d\u7684\u4f4d\u7f6e\u53c2\u6570\uff08\u65e0<code>*</code>\u5206\u9694\u7b26\uff09\u4f1a\u8f6c\u6362\u4e3a\u547d\u4ee4\u884c\u4f4d\u7f6e\u53c2\u6570</li> <li>\u53ef\u9009\u53c2\u6570\uff1a\u4f7f\u7528<code>*</code>\u5206\u9694\u7684\u5173\u952e\u5b57\u53c2\u6570\u4f1a\u8f6c\u6362\u4e3a\u547d\u4ee4\u884c\u53ef\u9009\u53c2\u6570\uff08\u5fc5\u987b\u4f7f\u7528<code>--</code>\u524d\u7f00\uff09</li> </ul>"},{"location":"zh/user_guide/argument/#literal","title":"Literal \u7c7b\u578b\u7684\u667a\u80fd\u5904\u7406","text":"<p>\u5f53\u53c2\u6570\u7c7b\u578b\u4e3a <code>Literal</code> \u65f6\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u8bbe\u7f6e <code>choices</code>\uff0c\u5e76\u6839\u636e\u9700\u8981\u8c03\u6574\u53c2\u6570\u884c\u4e3a\uff1a</p> <pre><code>from typing import Literal\n\n# \u81ea\u52a8\u8bbe\u7f6e choices\nlevel: Literal[\"debug\", \"info\", \"warning\", \"error\"]\n\n# \u4e0e\u9ed8\u8ba4\u503c\u7ed3\u5408\nlevel: Literal[\"debug\", \"info\", \"warning\", \"error\"] = \"info\"\n# \u751f\u6210: parser.add_argument(\"--level\", choices=..., default=\"info\")\n\n# \u4e0e\u5173\u952e\u5b57\u53c2\u6570\u7ed3\u5408\uff08\u81ea\u52a8\u6210\u4e3a\u53ef\u9009\u53c2\u6570\uff09\ndef do_set(\n    self,\n    *,\n    level: Literal[\"debug\", \"info\"] = \"info\"\n) -&gt; None:\n    pass\n# \u751f\u6210: parser.add_argument(\"--level\", ...)\n</code></pre> <p>\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u5728 <code>Argument</code> \u4e2d\u663e\u5f0f\u6307\u5b9a\u4e86 <code>choices</code> \u53c2\u6570\uff0c\u5c06\u8986\u76d6 <code>Literal</code> \u7c7b\u578b\u81ea\u52a8\u63a8\u5bfc\u7684\u9009\u9879\uff1a</p>"},{"location":"zh/user_guide/argument/#_10","title":"\u9ed8\u8ba4\u503c\u7684\u81ea\u52a8\u5904\u7406","text":"<p>\u9ed8\u8ba4\u503c\u4f1a\u76f4\u63a5\u5f71\u54cd\u53c2\u6570\u7684\u884c\u4e3a\uff1a</p> <pre><code># \u4f4d\u7f6e\u53c2\u6570\u5e26\u9ed8\u8ba4\u503c -&gt; \u53d8\u4e3a\u53ef\u9009\u4f4d\u7f6e\u53c2\u6570\ndef do_example(self, file: str = \"default.txt\") -&gt; None:\n    pass\n# \u751f\u6210: parser.add_argument(\"file\", nargs=\"?\", default=\"default.txt\")\n\n# \u5173\u952e\u5b57\u53c2\u6570\u5e26\u9ed8\u8ba4\u503c -&gt; \u6807\u51c6\u53ef\u9009\u53c2\u6570\ndef do_example(self, *, count: int = 1) -&gt; None:\n    pass\n# \u751f\u6210: parser.add_argument(\"--count\", type=int, default=1)\n</code></pre>"},{"location":"zh/user_guide/argument/#_11","title":"\u5904\u7406\u672a\u6ce8\u89e3\u7684\u53c2\u6570","text":"<p>\u5f53\u51fd\u6570\u53c2\u6570\u672a\u4f7f\u7528 <code>Arg</code> \u6216 <code>Argument</code> \u8fdb\u884c\u6ce8\u89e3\u65f6\uff0c<code>build_parser</code> \u63d0\u4f9b\u4e86\u4e09\u79cd\u5904\u7406\u6a21\u5f0f\uff0c\u901a\u8fc7 <code>unannotated_mode</code> \u53c2\u6570\u63a7\u5236\uff1a</p> <ul> <li>strict\uff1a\u4e25\u683c\u6a21\u5f0f\uff0c\u9047\u5230\u672a\u6ce8\u89e3\u7684\u53c2\u6570\u65f6\u629b\u51fa <code>TypeError</code></li> <li>autoconvert\uff1a\u81ea\u52a8\u8f6c\u6362\u6a21\u5f0f\uff0c\u5c1d\u8bd5\u6839\u636e\u7c7b\u578b\u6ce8\u89e3\u63a8\u65ad\u53c2\u6570\u914d\u7f6e</li> <li>ignore\uff1a\u5ffd\u7565\u6a21\u5f0f\uff0c\u8df3\u8fc7\u672a\u6ce8\u89e3\u7684\u53c2\u6570</li> </ul> <p><code>@auto_argument</code> \u88c5\u9970\u5668\u9ed8\u8ba4\u4f7f\u7528autoconvert\u6a21\u5f0f\u3002\u5728\u81ea\u52a8\u63a8\u65ad\u6a21\u5f0f\u4e0b\uff0c\u672a\u88ab\u6ce8\u89e3\u7684\u53c2\u6570<code>x: Tp</code>\u4f1a\u88ab\u89c6\u4e3a<code>x: Arg[Tp]</code>\u4ee5\u81ea\u52a8\u63a8\u65ad\u53c2\u6570\u4fe1\u606f\u3002</p> <pre><code>@auto_argument(unannotated_mode=\"autoconvert\")\ndef do_convert(self, x: int, *, y: str = \"y\") -&gt; None:\n    ...\n</code></pre> <p>\u5728 <code>autoconvert</code> \u6a21\u5f0f\u4e0b\uff0c\u4ee5\u4e0a\u7684\u4ee3\u7801\u4f1a\u88ab\u89c6\u4e3a</p> <pre><code>@auto_argument(unannotated_mode=\"autoconvert\")\ndef do_convert(self, x: Arg[int], *, y: Arg[str] = \"y\") -&gt; None:\n    ...\n</code></pre> <p>\u7ecf\u8fc7\u81ea\u52a8\u53c2\u6570\u63a8\u65ad\u540e\uff0c\u4ee5\u4e0a\u4ee3\u7801\u6700\u7ec8\u4f1a\u8f6c\u6362\u4e3a</p> <pre><code>@auto_argument(unannotated_mode=\"autoconvert\")\ndef do_convert(self, x: Annotated[int, Argument(\"x\", type=int)], *, y: Annotated[str, Argument(\"-y\", type=str, default=\"y\")] = \"y\") -&gt; None:\n    ...\n</code></pre>"},{"location":"zh/user_guide/argument/#_12","title":"\u72ec\u7acb\u4f7f\u7528\u53c2\u6570\u89e3\u6790","text":"<p>\u53c2\u6570\u89e3\u6790\u7cfb\u7edf\u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u72ec\u7acb\u7684\u51fd\u6570\uff0c\u7528\u4e8e\u72ec\u7acb\u4f7f\u7528\u53c2\u6570\u89e3\u6790\u529f\u80fd\u3002\u6700\u7b80\u5355\u7684\u65b9\u5f0f\u662f\u4f7f\u7528<code>entrypoint</code>\u88c5\u9970\u5668\uff1a</p> <pre><code>from ptcmd.argument import entrypoint\n\n@entrypoint\ndef main(\n    x: int,\n    *,\n    y: str = \"y\"\n) -&gt; None:\n    ...\n\nif __name__ == \"__main__\":\n    main()  # \u4ecesys.argv\u4e2d\u89e3\u6790\u53c2\u6570\u5e76\u8fd0\u884c\n</code></pre>"},{"location":"zh/user_guide/command/","title":"\u547d\u4ee4","text":"<p>\u4e3a\u4e86\u5728\u517c\u5bb9\u7c7b\u4f3c<code>cmd</code>\u7684\u4ee5\u624b\u52a8\u89e3\u6790\u4e3a\u4e3b\u7684\u547d\u4ee4\u7cfb\u7edf\u7684\u540c\u65f6\uff0c\u63d0\u4f9b\u4e0a\u5c42\u7684\u547d\u4ee4\u53c2\u6570\u81ea\u52a8\u89e3\u6790\u529f\u80fd\uff0c<code>ptcmd</code>\u4f7f\u7528\u4e86\u591a\u7ea7\u5206\u5c42\u7684\u547d\u4ee4\u7cfb\u7edf\u3002</p>"},{"location":"zh/user_guide/command/#_2","title":"\u547d\u4ee4\u5143\u4fe1\u606f","text":"<p>\u547d\u4ee4\u5143\u4fe1\u606f\u662f\u76f4\u63a5\u7531<code>BaseCmd</code>\u4e0e<code>Cmd</code>\u7c7b\u4f7f\u7528\u7684\u547d\u4ee4\u4fe1\u606f\uff1a</p> <pre><code>class CommandInfo(NamedTuple):\n    name: str\n    cmd_func: Callable[[List[str]], Any]\n    help_func: Optional[HelpGetterFunc] = None\n    category: Optional[str] = None\n    completer: Optional[Completer] = None\n    argparser: Optional[ArgumentParser] = None\n    hidden: bool = False\n    disabled: bool = False\n\n    def __cmd_info__(self, cmd_ins: \"BaseCmd\", /) -&gt; \"CommandInfo\":\n        return self\n</code></pre>"},{"location":"zh/user_guide/command/#_3","title":"\u547d\u4ee4\u4fe1\u606f\u6536\u96c6","text":"<p>\u7531\u4e8e\u547d\u4ee4\u540d\u79f0\u3001\u5904\u7406\u51fd\u6570\u7b49\u5747\u4f9d\u8d56<code>Cmd</code>\u5b9e\u4f8b\u672c\u8eab\u7684\u5c5e\u6027\u914d\u7f6e\u6216\u76f4\u63a5\u9700\u8981\u4e0e\u5b9e\u4f8b\u7ed1\u5b9a\uff0c\u56e0\u6b64\u547d\u4ee4\u4fe1\u606f\u6536\u96c6\u53d1\u751f\u5728<code>Cmd</code>\u5b9e\u4f8b\u521d\u59cb\u5316\u9636\u6bb5\u6700\u540e\u3002</p> <p>\u547d\u4ee4\u4fe1\u606f\u6536\u96c6\u7684\u903b\u8f91\u5982\u4e0b\uff1a</p> <pre><code>flowchart TD\n    G[BaseCmd\u5b9e\u4f8b\u5316] --&gt; H{\u904d\u5386__commands__\u96c6\u5408}\n    H --&gt; J[\u5bf9\u6bcf\u4e2a\u547d\u4ee4\u8c03\u7528\n        build_command_info]\n    J --&gt; K{\u547d\u4ee4\u7c7b\u578b\u5224\u65ad}\n    K --&gt;|Command\u5b9e\u4f8b| L[\u8c03\u7528\u547d\u4ee4\u7684__cmd_info__\u65b9\u6cd5]\n    K --&gt;|\u666e\u901a\u51fd\u6570| M[\u4ece\u51fd\u6570\u5c5e\u6027\u4e2d\u83b7\u53d6\u547d\u4ee4\u4fe1\u606f]\n    L --&gt; N[\u751f\u6210CommandInfo\u5bf9\u8c61]\n    M --&gt; N\n    N --&gt; O[\u5b58\u50a8\u5230command_info\u5b57\u5178]\n    O --&gt; H\n</code></pre> <ul> <li>\u5982\u679c\u5b58\u5728<code>__cmd_info__</code>\u65b9\u6cd5\uff0c\u5219\u8c03\u7528\u8be5\u65b9\u6cd5\u83b7\u53d6\u547d\u4ee4\u4fe1\u606f</li> <li>\u5426\u5219\uff0c\u4ece\u51fd\u6570\u5c5e\u6027\u4e2d\u83b7\u53d6\u547d\u4ee4\u4fe1\u606f</li> </ul>"},{"location":"zh/user_guide/command/#_4","title":"\u8bbe\u7f6e\u547d\u4ee4\u4fe1\u606f","text":"<p>\u53ef\u4ee5\u901a\u8fc7<code>ptcmd.info</code>\u6a21\u5757\u63d0\u4f9b\u7684<code>set_info</code>\u88c5\u9970\u5668\u6765\u624b\u52a8\u8bbe\u7f6e\u547d\u4ee4\u4fe1\u606f\uff1a</p> <pre><code>from argparse import ArgumentParser\nfrom ptcmd import Cmd, set_info\n\nclass App(Cmd):\n    _hello_parser = ArgumentParser(\"hello\")\n    _hello_parser.add_argument(\"name\", nargs=\"?\", default=\"World\", help=\"Name to greet\")\n\n    @set_info(name=\"hi\", help_category=\"Greeting\")\n    @set_info(argparser=_hello_parser)\n    def do_hello(self, argv: list[str]) -&gt; None:\n        ...\n</code></pre> <p>\u4e5f\u53ef\u4ee5\u901a\u8fc7\u521b\u5efa\u4e00\u4e2a\u5b9e\u73b0\u4e86<code>__cmd_info__</code>\u65b9\u6cd5\u7684\u5b9e\u4f8b\u6765\u81ea\u5b9a\u4e49\u8fd4\u56de\u7684\u547d\u4ee4\u4fe1\u606f\u3002\u76f8\u5173Protocol\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <pre><code>class CommandInfoGetter(Protocol):\n    def __cmd_info__(self, cmd_ins: \"BaseCmd\", /) -&gt; CommandInfo:\n        \"\"\"Get the command information for this command.\n\n        :param cmd_ins: The instance of the `cmd` class\n        :type cmd_ins: \"BaseCmd\"\n        :return: The command information\n        \"\"\"\n        ...\n</code></pre>"},{"location":"zh/user_guide/command/#command","title":"\u901a\u7528\u7684\u4e0a\u5c42\u547d\u4ee4\u5c01\u88c5\u2014\u2014Command","text":"<p>\u624b\u52a8\u8bbe\u7f6e\u547d\u4ee4\u4fe1\u606f\u867d\u7136\u63d0\u4f9b\u4e86\u66f4\u5f3a\u7684\u53ef\u63a7\u6027\uff0c\u4f46\u901a\u5e38\u6765\u8bf4\uff0c\u6211\u4eec\u66f4\u5e0c\u671b\u6709\u4e00\u4e2a\u66f4\u52a0\u7b80\u4fbf\u7684\u65b9\u5f0f\u6765\u5b9a\u4e49\u4e00\u822c\u7684\u547d\u4ee4\u3002</p> <p><code>Command</code>\u662f\u4e00\u4e2a\u901a\u7528\u7684\u547d\u4ee4\u5c01\u88c5\u7c7b\uff0c\u5b9e\u73b0\u4e86<code>__cmd_info__</code>\u65b9\u6cd5\uff0c\u5141\u8bb8\u4ee5\u81ea\u52a8\u6216\u624b\u52a8\u7684\u65b9\u5f0f\u8bbe\u7f6e\u547d\u4ee4\u4fe1\u606f\u3002\u4e0e\u76f4\u63a5\u4f7f\u7528<code>set_info</code>\u76f8\u6bd4\uff0c<code>Command</code>\u7c7b\u63d0\u4f9b\u4e86\u5982\u4e0b\u7684\u529f\u80fd\uff1a</p>"},{"location":"zh/user_guide/command/#_5","title":"\u58f0\u660e\u5f0f\u53c2\u6570\u89e3\u6790","text":"<p><code>Command</code>\u7c7b\u96c6\u6210\u4e86\u53c2\u6570\u89e3\u6790\u7cfb\u7edf\uff0c\u5141\u8bb8\u901a\u8fc7<code>@auto_argument</code>\u88c5\u9970\u5668\u548c<code>Arg</code>\u7c7b\u578b\u63d0\u793a\u63d0\u4f9b\u4e86\u58f0\u660e\u5f0f\u53c2\u6570\u89e3\u6790\u529f\u80fd\uff0c\u6d88\u9664\u4e86\u6837\u677f\u53c2\u6570\u89e3\u6790\u4ee3\u7801\u3002</p> <p>\u53c2\u6570\u89e3\u6790\u76f8\u5173\u5185\u5bb9\u53c2\u8003\u53c2\u6570\u89e3\u6790\u7cfb\u7edf\u3002</p>"},{"location":"zh/user_guide/command/#_6","title":"\u4efb\u610f\u591a\u7ea7\u5b50\u547d\u4ee4","text":"<p><code>ptcmd</code>\u652f\u6301\u4e3a\u4e00\u4e2a\u547d\u4ee4\u6dfb\u52a0\u4efb\u610f\u591a\u7ea7\u5b50\u547d\u4ee4\uff0c\u8fd9\u4f7f\u5f97\u6784\u5efa\u590d\u6742\u7684\u547d\u4ee4\u5c42\u6b21\u7ed3\u6784\u53d8\u5f97\u7b80\u5355\u3002</p>"},{"location":"zh/user_guide/command/#_7","title":"\u57fa\u7840\u5b50\u547d\u4ee4\u7528\u6cd5","text":"<p>\u901a\u8fc7<code>add_subcommand</code>\u65b9\u6cd5\u53ef\u4ee5\u4e3a\u547d\u4ee4\u6dfb\u52a0\u5b50\u547d\u4ee4\uff1a</p> <pre><code>from ptcmd import Cmd, auto_argument\n\nclass App(Cmd):\n    @auto_argument\n    def do_server(self):\n        \"\"\"\u670d\u52a1\u5668\u7ba1\u7406\"\"\"\n\n    @do_server.add_subcommand(\"start\")\n    def server_start(self):\n        \"\"\"\u542f\u52a8\u670d\u52a1\u5668\"\"\"\n        self.poutput(\"\u670d\u52a1\u5668\u5df2\u542f\u52a8\")\n\n    @do_server.add_subcommand(\"stop\")\n    def server_stop(self):\n        \"\"\"\u505c\u6b62\u670d\u52a1\u5668\"\"\"\n        self.poutput(\"\u670d\u52a1\u5668\u5df2\u505c\u6b62\")\n</code></pre> <p>\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c<code>do_server</code>\u662f\u4e3b\u547d\u4ee4\uff0c<code>server_start</code>\u548c<code>server_stop</code>\u662f\u5b83\u7684\u5b50\u547d\u4ee4\u3002\u7528\u6237\u53ef\u4ee5\u901a\u8fc7<code>server start</code>\u548c<code>server stop</code>\u6765\u8c03\u7528\u8fd9\u4e9b\u5b50\u547d\u4ee4\u3002</p>"},{"location":"zh/user_guide/command/#_8","title":"\u591a\u7ea7\u5d4c\u5957\u5b50\u547d\u4ee4","text":"<p><code>ptcmd</code>\u652f\u6301\u4efb\u610f\u5c42\u7ea7\u7684\u5b50\u547d\u4ee4\u5d4c\u5957\uff1a</p> <pre><code>from ptcmd import Cmd, auto_argument\n\nclass App(Cmd):\n    @auto_argument\n    def do_server(self):\n        \"\"\"\u670d\u52a1\u5668\u7ba1\u7406\"\"\"\n\n    @do_server.add_subcommand(\"db\")\n    def db(self):\n        \"\"\"\u6570\u636e\u5e93\u7ba1\u7406\"\"\"\n\n    @db.add_subcommand(\"migrate\")\n    def migrate(self, version: str):\n        \"\"\"\u6267\u884c\u6570\u636e\u5e93\u8fc1\u79fb\"\"\"\n        self.poutput(f\"\u6b63\u5728\u8fc1\u79fb\u5230\u7248\u672c {version}...\")\n\n    @do_server.add_subcommand(\"cache\")\n    def cache(self):\n        \"\"\"\u7f13\u5b58\u7ba1\u7406\"\"\"\n\n    @cache.add_subcommand(\"clear\")\n    def clear(self, confirm: bool = False):\n        \"\"\"\u6e05\u9664\u7f13\u5b58\"\"\"\n        if confirm:\n            self.poutput(\"\u7f13\u5b58\u5df2\u6e05\u9664\")\n        else:\n            self.poutput(\"\u8bf7\u6dfb\u52a0--confirm\u53c2\u6570\u786e\u8ba4\u64cd\u4f5c\")\n</code></pre> <p>\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e24\u7ea7\u5b50\u547d\u4ee4\u7ed3\u6784\uff1a - <code>server</code> (\u4e3b\u547d\u4ee4)   - <code>db</code> (\u5b50\u547d\u4ee4)     - <code>migrate</code> (\u4e8c\u7ea7\u5b50\u547d\u4ee4)   - <code>cache</code> (\u5b50\u547d\u4ee4)     - <code>clear</code> (\u4e8c\u7ea7\u5b50\u547d\u4ee4)</p> <p>\u7528\u6237\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u547d\u4ee4\u8c03\u7528\u8fd9\u4e9b\u529f\u80fd\uff1a - <code>server db migrate v1.0</code> - <code>server cache clear --confirm</code></p>"},{"location":"zh/user_guide/command/#_9","title":"\u5b9e\u73b0\u539f\u7406","text":"<p>\u7cfb\u7edf\u901a\u8fc7<code>ArgumentParser</code>\u7684<code>defaults</code>\u673a\u5236\u5b9e\u73b0\u547d\u4ee4\u4e0a\u4e0b\u6587\u4f20\u9012\uff1a</p> <ul> <li>\u53f6\u8282\u70b9\u7ed1\u5b9a\uff1a\u5728\u6784\u5efa\u5b50\u547d\u4ee4\u89e3\u6790\u5668\u65f6\uff0c\u5c06\u53f6\u8282\u70b9\u547d\u4ee4\u5b9e\u4f8b\u6ce8\u5165<code>defaults</code>\u5b57\u5178</li> <li>\u8986\u76d6\u7279\u6027\uff1a\u5f53\u5b50\u547d\u4ee4\u88ab\u89e6\u53d1\u65f6\uff0c\u4f1a\u8986\u76d6\u7236\u547d\u4ee4\u7684<code>defaults</code>\u8bbe\u7f6e\uff0c\u81ea\u7136\u5f62\u6210\u6307\u5411\u6700\u6df1\u5c42\u547d\u4ee4\u7684\u5f15\u7528</li> <li>\u89e3\u6790\u7ed3\u679c\u5173\u8054\uff1a\u6700\u7ec8\u547d\u540d\u7a7a\u95f4\u7684<code>__cmd_ins__</code>\u5c5e\u6027\u76f4\u63a5\u5173\u8054\u5230\u53f6\u8282\u70b9\u547d\u4ee4\u5b9e\u4f8b</li> </ul> <p>\u8fd9\u79cd\u8bbe\u8ba1\u5de7\u5999\u5229\u7528<code>argparse</code>\u7684\u539f\u751f\u673a\u5236\u2014\u2014\u5b50\u547d\u4ee4\u89e3\u6790\u5668\u4f1a\u8986\u76d6\u7236\u547d\u4ee4\u7684\u9ed8\u8ba4\u503c\uff0c\u4f7f\u7cfb\u7edf\u80fd\u5728\u6807\u51c6\u89e3\u6790\u6d41\u7a0b\u7ed3\u675f\u540e\uff0c\u76f4\u63a5\u83b7\u53d6\u5230\u7ec8\u7aef\u547d\u4ee4\u7684\u6267\u884c\u4e0a\u4e0b\u6587\uff0c\u65e0\u9700\u989d\u5916\u67e5\u627e\u3002</p> <p>\u7cfb\u7edf\u91c7\u7528\u8f7b\u91cf\u7ea7\u5f15\u7528\u94fe\u6784\u5efa\u547d\u4ee4\u5c42\u7ea7\uff1a</p> <pre><code>flowchart BT\n    F[\u4e09\u7ea7\u5b50\u547d\u4ee4] --&gt;|_parent| D[\u4e8c\u7ea7\u5b50\u547d\u4ee4]\n    D --&gt;|_parent| B[\u4e00\u7ea7\u5b50\u547d\u4ee4]\n    E[\u53e6\u4e00\u4e8c\u7ea7\u5b50\u547d\u4ee4] --&gt;|_parent| B\n    B --&gt;|_parent| A[\u6839\u547d\u4ee4]\n    C[\u53e6\u4e00\u7ea7\u5b50\u547d\u4ee4] --&gt;|_parent| A\n</code></pre> <p>\u6838\u5fc3\u673a\u5236\uff1a</p> <ul> <li>\u53cd\u5411\u5f15\u7528\uff1a\u6bcf\u4e2a\u5b50\u547d\u4ee4\u5b9e\u4f8b\u4ec5\u4fdd\u5b58\u5bf9\u5176\u76f4\u63a5\u7236\u547d\u4ee4\u7684\u5f15\u7528</li> <li>\u52a8\u6001\u6784\u5efa\uff1a\u547d\u4ee4\u6811\u5728\u89e3\u6790\u8fc7\u7a0b\u4e2d\u81ea\u7136\u5f62\u6210\uff0c\u65e0\u9700\u9884\u5b9a\u4e49\u7ed3\u6784</li> <li>\u8def\u5f84\u91cd\u5efa\uff1a\u901a\u8fc7\u9012\u5f52\u8bbf\u95ee<code>_parent</code>\u5c5e\u6027\u53ef\u91cd\u5efa\u5b8c\u6574\u8c03\u7528\u8def\u5f84</li> <li>\u4f4e\u5f00\u9500\uff1a\u6bcf\u4e2a\u547d\u4ee4\u4ec5\u589e\u52a0\u4e00\u4e2a\u5f15\u7528\u5173\u7cfb\uff0c\u907f\u514d\u4e2d\u5fc3\u5316\u6ce8\u518c\u8868</li> </ul> <p>\u8fd9\u79cd\u8bbe\u8ba1\u5b8c\u5168\u57fa\u4e8e<code>argparse</code>\u7684\u5b50\u547d\u4ee4\u673a\u5236\uff0c\u901a\u8fc7\u6700\u5c0f\u5316\u6269\u5c55\u5b9e\u73b0\u4e86\u4efb\u610f\u6df1\u5ea6\u7684\u547d\u4ee4\u5d4c\u5957\u3002</p> <p>\u6267\u884c\u6d41\u7a0b\u805a\u7126\u4e8e\u89e3\u6790\u540e\u5904\u7406\uff1a</p> <pre><code>flowchart LR\n    Q[argparse\u89e3\u6790\u5b8c\u6210] --&gt; R[\u94fe\u91cd\u5efa]\n    R --&gt; S[\u6b63\u5411\u6267\u884c]\n</code></pre> <ol> <li>\u94fe\u91cd\u5efa\u9636\u6bb5\uff1a</li> <li>\u4ece<code>__cmd_ins__</code>\u83b7\u53d6\u53f6\u8282\u70b9\u547d\u4ee4\u5b9e\u4f8b</li> <li>\u901a\u8fc7<code>_parent</code>\u5f15\u7528\u5411\u4e0a\u904d\u5386\u6784\u5efa\u5b8c\u6574\u547d\u4ee4\u94fe</li> <li> <p>\u9a8c\u8bc1\u94fe\u7684\u5b8c\u6574\u6027\u548c\u8282\u70b9\u72b6\u6001</p> </li> <li> <p>\u6b63\u5411\u6267\u884c\u9636\u6bb5\uff1a</p> </li> <li>\u5c06\u547d\u4ee4\u94fe\u53cd\u8f6c\u4e3a\u6839\u2192\u53f6\u987a\u5e8f</li> <li>\u4f9d\u6b21\u6267\u884c\u5404\u5c42\u7ea7\u547d\u4ee4\uff0c\u4f20\u9012\u4e2d\u95f4\u7ed3\u679c</li> <li>\u8fd4\u56de\u53f6\u8282\u70b9\u7684\u6700\u7ec8\u6267\u884c\u7ed3\u679c</li> </ol> <p>\u5173\u952e\u4ef7\u503c\u5728\u4e8e\uff1a\u5145\u5206\u5229\u7528\u6807\u51c6\u89e3\u6790\u7ed3\u679c\uff0c\u901a\u8fc7\u53f6\u8282\u70b9\u91cd\u5efa\u6267\u884c\u8def\u5f84\u540e\u6b63\u5411\u6267\u884c\u3002\u7cfb\u7edf\u4e0d\u5e72\u9884<code>argparse</code>\u7684\u89e3\u6790\u8fc7\u7a0b\uff0c\u4ec5\u5728\u89e3\u6790\u5b8c\u6210\u540e\u6ce8\u5165\u6267\u884c\u903b\u8f91\uff0c\u65e2\u4fdd\u6301\u4e0e\u6807\u51c6\u5e93\u7684\u517c\u5bb9\u6027\uff0c\u53c8\u5b9e\u73b0\u4e86\u590d\u6742\u7684\u547d\u4ee4\u7ed3\u6784\u652f\u6301\u3002</p>"},{"location":"zh/user_guide/command/#_10","title":"\u5e2e\u52a9","text":"<p>ptcmd \u7cfb\u7edf\u63d0\u4f9b\u4e24\u79cd\u4e92\u8865\u7684\u5e2e\u52a9\u4fe1\u606f\u673a\u5236\uff0c\u5206\u522b\u670d\u52a1\u4e8e\u4e0d\u540c\u573a\u666f\uff1a</p>"},{"location":"zh/user_guide/command/#argumentparser","title":"ArgumentParser \u5185\u7f6e\u5e2e\u52a9\u7cfb\u7edf","text":"<p>\u8fd9\u662f\u6807\u51c6\u7684\u547d\u4ee4\u884c\u5e2e\u52a9\u7cfb\u7edf\uff0c\u901a\u8fc7 <code>-h</code>/<code>--help</code> \u53c2\u6570\u89e6\u53d1\uff0c\u63d0\u4f9b\u8be6\u7ec6\u7684\u547d\u4ee4\u53c2\u6570\u4fe1\u606f\uff1a</p>"},{"location":"zh/user_guide/command/#_11","title":"\u57fa\u672c\u7528\u6cd5","text":"<pre><code>command -h\n</code></pre>"},{"location":"zh/user_guide/command/#_12","title":"\u5de5\u4f5c\u539f\u7406","text":"<ul> <li>\u7531 Python \u6807\u51c6\u5e93 <code>argparse</code> \u6a21\u5757\u63d0\u4f9b</li> <li>\u81ea\u52a8\u89e3\u6790\u547d\u4ee4\u53c2\u6570\u7ed3\u6784\u5e76\u751f\u6210\u683c\u5f0f\u5316\u7684\u5e2e\u52a9\u4fe1\u606f</li> <li>\u8be6\u7ec6\u663e\u793a:</li> <li>\u547d\u4ee4\u63cf\u8ff0 (ArgumentParser \u7684 description \u53c2\u6570)</li> <li>\u6240\u6709\u53ef\u7528\u53c2\u6570\u53ca\u5176\u8bf4\u660e</li> <li>\u53c2\u6570\u7c7b\u578b\u3001\u9ed8\u8ba4\u503c\u548c\u7ea6\u675f</li> <li>\u5b50\u547d\u4ee4\u5217\u8868 (\u5982\u6709)</li> </ul>"},{"location":"zh/user_guide/command/#_13","title":"\u914d\u7f6e\u65b9\u5f0f","text":"<p>\u901a\u8fc7 ArgumentParser \u5bf9\u8c61\u914d\u7f6e\u5e2e\u52a9\u5185\u5bb9: <pre><code>_hello_parser = ArgumentParser(\n    \"hello\", \n    description=\"\u95ee\u5019\u7528\u6237\u3002\u4f7f\u7528 'hello [name]' \u6307\u5b9a\u540d\u79f0\",\n    epilog=\"\u66f4\u591a\u793a\u4f8b\u8bf7\u53c2\u8003\u6587\u6863\"\n)\n\n@set_info(argparser=_hello_parser)\ndef do_hello(self, argv: list[str]) -&gt; None:\n    ...\n</code></pre></p>"},{"location":"zh/user_guide/command/#_14","title":"\u591a\u7ea7\u5b50\u547d\u4ee4\u652f\u6301","text":"<ul> <li><code>server -h</code> \u663e\u793a server \u547d\u4ee4\u53ca\u5176\u5b50\u547d\u4ee4\u7684\u6982\u89c8</li> <li><code>server start -h</code> \u663e\u793a start \u5b50\u547d\u4ee4\u7684\u8be6\u7ec6\u53c2\u6570\u4fe1\u606f</li> </ul>"},{"location":"zh/user_guide/command/#help","title":"help \u547d\u4ee4","text":"<p>\u8fd9\u662f ptcmd \u63d0\u4f9b\u7684\u9ad8\u7ea7\u547d\u4ee4\u5e2e\u52a9\u7cfb\u7edf\uff0c\u901a\u8fc7 <code>help</code> \u547d\u4ee4\u89e6\u53d1\uff0c\u63d0\u4f9b\u66f4\u53cb\u597d\u7684\u4ea4\u4e92\u5f0f\u5e2e\u52a9\uff1a</p>"},{"location":"zh/user_guide/command/#_15","title":"\u57fa\u672c\u7528\u6cd5","text":"<pre><code>help            # \u663e\u793a\u6240\u6709\u53ef\u7528\u547d\u4ee4\u6982\u89c8\nhelp command    # \u663e\u793a\u7279\u5b9a\u547d\u4ee4\u7684\u7b80\u8981\u8bf4\u660e\nhelp command -v # \u663e\u793a\u7279\u5b9a\u547d\u4ee4\u7684\u8be6\u7ec6\u53c2\u6570\u8bf4\u660e\n?               # \u7b49\u540c\u4e8e help\n?command        # \u7b49\u540c\u4e8e help command\n</code></pre>"},{"location":"zh/user_guide/command/#_16","title":"\u5e2e\u52a9\u4fe1\u606f\u6765\u6e90","text":"<p>ptcmd \u7684 help \u547d\u4ee4\u4ece\u4ee5\u4e0b\u4f4d\u7f6e\u83b7\u53d6\u4fe1\u606f:</p> <ol> <li> <p>\u547d\u4ee4\u6587\u6863\u5b57\u7b26\u4e32:    <pre><code>def do_hello(self, argv: list[str]) -&gt; None:\n    \"\"\"\u95ee\u5019\u7528\u6237\u3002\u4f7f\u7528 'hello [name]' \u6307\u5b9a\u540d\u79f0\"\"\"\n    ...\n</code></pre>    \u8fd9\u5c06\u4f5c\u4e3a <code>help hello</code> \u7684\u7b80\u8981\u8bf4\u660e</p> </li> <li> <p>\u52a8\u6001 help_ \u65b9\u6cd5:    <pre><code>def help_hello(self) -&gt; str:\n    \"\"\"\u52a8\u6001\u751f\u6210 hello \u547d\u4ee4\u7684\u5e2e\u52a9\u4fe1\u606f\"\"\"\n    return \"\u5f53\u524d\u7528\u6237: \" + self.current_user + \"\\n\u7528\u6cd5: hello [name]\"\n</code></pre>    \u4f18\u5148\u7ea7\u9ad8\u4e8e\u6587\u6863\u5b57\u7b26\u4e32 <li> <p>\u547d\u4ee4\u5143\u6570\u636e:    <pre><code>@set_info(help_category=\"Greeting\")\ndef do_hello(self, argv: list[str]) -&gt; None:\n    \"\"\"\u95ee\u5019\u7528\u6237\"\"\"\n    ...\n</code></pre>    \u7528\u4e8e\u7ec4\u7ec7\u547d\u4ee4\u5206\u7c7b\u663e\u793a</p> </li>"},{"location":"zh/user_guide/command/#_17","title":"\u5e2e\u52a9\u5206\u7c7b\u4e0e\u7ec4\u7ec7","text":"<ul> <li>\u901a\u8fc7 <code>help_category</code> \u53c2\u6570\u5bf9\u547d\u4ee4\u8fdb\u884c\u5206\u7ec4</li> <li>\u9690\u85cf\u547d\u4ee4 (<code>hidden=True</code>) \u4e0d\u4f1a\u5728 help \u8f93\u51fa\u4e2d\u663e\u793a</li> <li>\u7981\u7528\u547d\u4ee4 (<code>disabled=True</code>) \u4f1a\u663e\u793a\u4f46\u6807\u8bb0\u4e3a\u4e0d\u53ef\u7528</li> </ul>"},{"location":"zh/user_guide/command/#_18","title":"\u4e24\u79cd\u5e2e\u52a9\u7cfb\u7edf\u7684\u534f\u540c\u5de5\u4f5c","text":"\u7279\u6027 ArgumentParser (-h) help \u547d\u4ee4 \u4e3b\u8981\u7528\u9014 \u8be6\u7ec6\u53c2\u6570\u53c2\u8003 \u547d\u4ee4\u6982\u89c8\u4e0e\u5feb\u901f\u53c2\u8003 \u89e6\u53d1\u65b9\u5f0f <code>command -h</code> <code>help</code> \u6216 <code>?</code> \u5185\u5bb9\u6df1\u5ea6 \u8be6\u7ec6\u53c2\u6570\u8bf4\u660e \u7b80\u8981\u547d\u4ee4\u63cf\u8ff0 \u52a8\u6001\u5185\u5bb9 \u6709\u9650 (\u4e3b\u8981\u9759\u6001) \u652f\u6301\u52a8\u6001\u751f\u6210 \u6700\u4f73\u573a\u666f \u9700\u8981\u4e86\u89e3\u5177\u4f53\u53c2\u6570\u7528\u6cd5\u65f6 \u6d4f\u89c8\u53ef\u7528\u547d\u4ee4\u53ca\u57fa\u672c\u7528\u6cd5\u65f6"},{"location":"zh/user_guide/core/","title":"\u6838\u5fc3\u6846\u67b6\u2014\u2014BaseCmd/Cmd","text":"<p><code>BaseCmd</code>\u548c<code>Cmd</code>\u7c7b\u662f<code>ptcmd</code>\u7684\u6838\u5fc3\u6846\u67b6\uff0c\u5141\u8bb8\u7528\u6237\u901a\u8fc7\u7ee7\u627f\u7684\u65b9\u5f0f\u521b\u5efa\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5e94\u7528\u3002</p> <p><code>BaseCmd</code>\u4e0e<code>Cmd</code>\u7c7b\u7684\u533a\u522b\u662f<code>Cmd</code>\u7c7b\u63d0\u4f9b\u4e86<code>help</code>\u3001<code>exit</code>\u548c<code>shell</code>\u4e09\u4e2a\u57fa\u7840\u547d\u4ee4\uff0c\u800c<code>BaseCmd</code>\u7c7b\u5219\u6ca1\u6709\u5185\u7f6e\u547d\u4ee4\uff0c\u9700\u8981\u7528\u6237\u81ea\u884c\u5b9a\u4e49\u3002</p>"},{"location":"zh/user_guide/core/#_1","title":"\u517c\u5bb9\u6027","text":"<p>\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c<code>ptcmd</code>\u5e76\u4e0d\u4e0e\u6807\u51c6\u5e93<code>cmd</code>\u517c\u5bb9\u3002\u8fd9\u4e3b\u8981\u53d6\u51b3\u4e8e\u4ee5\u4e0b\u51e0\u4e2a\u65b9\u9762\uff1a</p> <ul> <li>\u547d\u4ee4\u53c2\u6570\uff1a<code>ptcmd</code>\u4f20\u9012\u7ed9\u547d\u4ee4\u65b9\u6cd5\u7684\u53c2\u6570\u662f\u5df2\u7ecf\u5206\u5272\u597d\u7684\u53c2\u6570\u5217\u8868\uff0c\u800c<code>cmd</code>\u4f20\u9012\u7ed9\u547d\u4ee4\u65b9\u6cd5\u7684\u53c2\u6570\u662f\u53bb\u9664\u547d\u4ee4\u540d\u79f0\u7684\u5b57\u7b26\u4e32\u3002</li> </ul> <p>Ptcmd</p> <pre><code>from ptcmd import BaseCmd\n\nclass MyApp(BaseCmd):\n    def do_hello(self, argv: list[str]) -&gt; None:\n        ...\n</code></pre> <p>Cmd</p> <pre><code>from cmd import Cmd\n\nclass MyApp(Cmd):\n    def do_hello(self, arg: str) -&gt; None:\n        ...\n</code></pre> <ul> <li>\u547d\u4ee4\u6536\u96c6\u65b9\u5f0f\uff1a<code>cmd</code>\u4e0d\u4f1a\u9884\u5148\u6536\u96c6\u547d\u4ee4\uff0c\u53ea\u901a\u8fc7\u8fd0\u884c\u65f6\u8bfb\u53d6\u5b9e\u4f8b\u5c5e\u6027\u5217\u8868\u6765\u641c\u7d22\u5e76\u6267\u884c\u547d\u4ee4\uff0c\u53ef\u4ee5\u5728\u5b9e\u4f8b\u521d\u59cb\u5316\u540e\u901a\u8fc7\u8bbe\u7f6e\u5c5e\u6027\u6765\u52a8\u6001\u6dfb\u52a0\u547d\u4ee4\uff1b\u800c<code>ptcmd</code>\u62e5\u6709\u66f4\u5b8c\u5584\u7684\u547d\u4ee4\u6536\u96c6\u65b9\u5f0f\uff0c\u6240\u6709\u547d\u4ee4\u9700\u8981\u9884\u5148\u6536\u96c6\u5e76\u5728\u521d\u59cb\u5316\u65f6\u83b7\u53d6\u547d\u4ee4\u4fe1\u606f\uff0c\u4e0d\u5141\u8bb8\u7b80\u5355\u7684\u901a\u8fc7\u5c5e\u6027\u4fee\u6539\u6765\u589e\u5220\u547d\u4ee4\uff0c\u8be6\u7ec6\u4fe1\u606f\u89c1\u547d\u4ee4\u6536\u96c6</li> </ul> <p>\u5982\u679c\u4f60\u5e0c\u671b\u5bfb\u627e\u4e00\u4e2a\u4e0e\u6807\u51c6\u5e93<code>cmd</code>\u517c\u5bb9\u7684\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u5f00\u53d1\u6846\u67b6\uff0c\u8bf7\u4f7f\u7528<code>cmd2</code>\u3002</p>"},{"location":"zh/user_guide/core/#_2","title":"\u547d\u4ee4\u6536\u96c6","text":"<p><code>BaseCmd</code>\u901a\u8fc7\u7c7b\u4e2d\u5b9a\u4e49\u7684\u65b9\u6cd5\u540d\u79f0\u524d\u7f00\u6765\u6536\u96c6\u547d\u4ee4\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6240\u6709\u4ee5<code>do_</code>\u5f00\u5934\u7684\u65b9\u6cd5\u90fd\u4f1a\u88ab\u6536\u96c6\u4e3a\u547d\u4ee4\u3002</p> <p>\u547d\u4ee4\u7684\u6536\u96c6\u53d1\u751f\u5728\u7c7b\u521b\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u56e0\u6b64\u5728\u521b\u5efa\u540e\u6dfb\u52a0\u7684\u65b0\u5c5e\u6027\u5c06\u4e0d\u4f1a\u88ab\u6536\u96c6\u4e3a\u547d\u4ee4\u3002\u5982\u679c\u5e0c\u671b\u6dfb\u52a0\u65b0\u7684\u547d\u4ee4\uff0c\u5bf9\u4e8e\u7c7b\u6765\u8bf4\u5e94\u8be5\u663e\u793a\u66f4\u6539<code>__commands__</code>\u5c5e\u6027\uff0c\u5bf9\u4e8e\u5b9e\u4f8b\u5219\u9700\u8981\u66f4\u6539<code>command_info</code>\u5c5e\u6027\u3002</p> <pre><code>graph TD\n    A[BaseCmd\u5b50\u7c7b\u5b9a\u4e49] --&gt; C[\u7ee7\u627f\u7236\u7c7b\u547d\u4ee4\u96c6\u5408];\n    C --&gt; D[\u904d\u5386\u7c7b\u7684\u6240\u6709\u5c5e\u6027];\n    D --&gt; E{\u5c5e\u6027\u540d\u662f\u5426\u4ee5\n        COMMAND_FUNC_PREFIX\n        \u5f00\u5934?};\n    E --&gt;|\u662f| F[\u5c06\u5c5e\u6027\u6dfb\u52a0\u5230\u547d\u4ee4\u96c6\u5408];\n    E --&gt;|\u5426| G[\u5ffd\u7565\u8be5\u5c5e\u6027];\n    F --&gt; H[\u7c7b\u521b\u5efa\u5b8c\u6210];\n    G --&gt; H;\n    H --&gt; I[\u83b7\u53d6\u6bcf\u4e2a\u547d\u4ee4\u7684\u4fe1\u606f];\n    I --&gt; J{\u547d\u4ee4\u662f\u5426\u91cd\u540d?};\n    J --&gt;|\u662f| K[\u629b\u51faValueError\u5f02\u5e38];\n    J --&gt;|\u5426| L[\u5b58\u50a8\u547d\u4ee4\u4fe1\u606f\u5230\n        command_info\u5b57\u5178];\n    L --&gt; M[\u547d\u4ee4\u6536\u96c6\u5b8c\u6210];\n\n    subgraph \u547d\u4ee4\u6536\u96c6\u9636\u6bb5\n        C;\n        D;\n        E;\n        F;\n        G;\n        H;\n    end;\n\n    subgraph \u521d\u59cb\u5316\u9636\u6bb5\n        I;\n        J;\n        K;\n        L;\n        M;\n    end;\n</code></pre>"},{"location":"zh/user_guide/core/#_3","title":"\u66f4\u6539\u547d\u4ee4\u524d\u7f00","text":"<p>\u547d\u4ee4\u524d\u7f00\u7531\u7c7b\u5c5e\u6027<code>COMMAND_FUNC_PREFIX</code>\u6307\u5b9a\uff1a</p> <pre><code>class BaseCmd(object, metaclass=ABCMeta):\n    ...\n    COMMAND_FUNC_PREFIX = \"do_\"\n</code></pre> <p>\u53ef\u4ee5\u901a\u8fc7\u5728\u521b\u5efa\u5b50\u7c7b\u65f6\u4fee\u6539\u7c7b\u5c5e\u6027<code>COMMAND_FUNC_PREFIX</code>\u6765\u66f4\u6539\u547d\u4ee4\u8bc6\u522b\u7684\u524d\u7f00\u3002</p> <p>Warning</p> <p>\u8fd9\u662f\u4e00\u4e2a\u5371\u9669\u7684\u64cd\u4f5c\uff0c\u4f60\u9700\u6c42\u786e\u4fdd\uff1a</p> <ol> <li>\u4e0d\u5e94\u5f53\u4fee\u6539\u73b0\u6709\u7c7b\u7684\u547d\u4ee4\u524d\u7f00\uff0c\u8fd9\u5e76\u4e0d\u4f1a\u6539\u53d8\u5df2\u7ecf\u6536\u96c6\u5230\u7684\u547d\u4ee4\u540d\u79f0\uff0c\u53ea\u4f1a\u5e26\u6765\u9519\u8bef\u3002</li> <li>\u4fee\u6539\u547d\u4ee4\u524d\u7f00\u65f6\u6700\u597d\u4e0d\u8981\u7ee7\u627f\u5df2\u5b58\u5728\u547d\u4ee4\u7684\u7236\u7c7b\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u6240\u6709\u7236\u7c7b\u7684\u547d\u4ee4\u5168\u90e8\u5931\u6548\u3002</li> <li>\u5728\u591a\u7ee7\u627f\u7684\u60c5\u51b5\u4e0b\uff0c\u6240\u6709\u7236\u7c7b\u5fc5\u987b\u62e5\u6709\u540c\u6837\u7684\u547d\u4ee4\u524d\u7f00\u3002</li> </ol>"},{"location":"zh/user_guide/core/#_4","title":"\u8f93\u5165\u8f93\u51fa","text":"<p>\u8f93\u5165\u8f93\u51fa\u662f<code>ptcmd</code>\u7684\u6838\u5fc3\u529f\u80fd\uff0c\u5b83\u5141\u8bb8\u7528\u6237\u8f93\u5165\u547d\u4ee4\u5e76\u83b7\u53d6\u547d\u4ee4\u6267\u884c\u7ed3\u679c\u3002<code>ptcmd</code>\u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684\u8f93\u5165\u8f93\u51fa\u529f\u80fd\uff0c\u5305\u62ec\u547d\u4ee4\u884c\u63d0\u793a\u3001\u81ea\u52a8\u8865\u5168\u3001\u5386\u53f2\u8bb0\u5f55\u3001\u547d\u4ee4\u6267\u884c\u7ed3\u679c\u683c\u5f0f\u5316\u3001\u9519\u8bef\u5904\u7406\u7b49\u3002</p>"},{"location":"zh/user_guide/core/#_5","title":"\u8f93\u51fa","text":"<p><code>Cmd</code>\u5bf9\u8c61\u63d0\u4f9b\u4e86\u5982\u4e0b\u7684\u5185\u7f6e\u8f93\u51fa\u65b9\u5f0f\uff0c\u5728\u6ca1\u6709\u7279\u6b8a\u9700\u8981\u7684\u60c5\u51b5\u4e0b\uff0c\u8bf7\u5c3d\u91cf\u4f7f\u7528\u8fd9\u4e9b\u5185\u7f6e\u8f93\u51fa\u65b9\u5f0f\u4ee5\u907f\u514d\u540e\u53f0\u4efb\u52a1\u8f93\u51fa\u6253\u65ad\u4ea4\u4e92\u8f93\u5165\uff1a</p> <ul> <li><code>cmd.stdout</code>\uff1a\u8fd9\u662f\u4e00\u4e2a<code>prompt_toolkit</code>\u7684<code>StdoutProxy</code>\u5bf9\u8c61\uff0c\u4e0e<code>io.TextIOWrapper</code>\u517c\u5bb9\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528\u4e8e\u66ff\u6362<code>sys.stdout</code>\u3002</li> <li><code>cmd.console</code>\uff1a\u5efa\u7acb\u5728<code>cmd.stdout</code>\u4e4b\u4e0a\u7684<code>rich.console.Console</code>\u5bf9\u8c61\uff0c\u652f\u6301\u5bcc\u6587\u672c\u8f93\u51fa\u3002</li> <li><code>cmd.poutput()</code>\u7cfb\u5217\u65b9\u6cd5\uff1a<code>cmd.console</code>\u7684\u7b80\u5355\u5c01\u88c5\u3002</li> </ul>"},{"location":"zh/user_guide/core/#_6","title":"\u975e\u4ea4\u4e92\u5f0f\u8f93\u5165","text":"<p>\u5982\u679c\u8f93\u5165\u6d41\u4e0d\u662f\u4ea4\u4e92\u5f0f\u7684\uff0c<code>BaseCmd</code>\u5c06\u8df3\u8fc7<code>prompt_toolkit</code>\u7684\u4ea4\u4e92\u4f1a\u8bdd\u521b\u5efa\uff0c\u56de\u9000\u5230\u666e\u901a\u7684\u6587\u4ef6\u8f93\u5165\u903b\u8f91\u3002\u8fd9\u5141\u8bb8\u5728\u547d\u4ee4\u884c\u4e2d\u901a\u8fc7\u8f93\u5165\u91cd\u5b9a\u5411\u6216\u7ba1\u9053\u8fde\u63a5\u7684\u65b9\u5f0f\u8c03\u7528<code>ptcmd</code>\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u4e00\u4e2a\u6216\u591a\u4e2a\u547d\u4ee4\u3002</p> \u8f93\u5165\u91cd\u5b9a\u5411\u7ba1\u9053\u8fde\u63a5 <pre><code>$ python examples/hello.py &lt;&lt;EOF\n&gt; hello\n&gt; hello Alice\n&gt; EOF\nHello World!\nHello Alice!\n</code></pre> <pre><code>$ echo -e \"hello\\nhello Alice\" | python examples/hello.py \nHello, World!\nHello, Alice!\n</code></pre>"},{"location":"zh/user_guide/core/#_7","title":"\u81ea\u5b9a\u4e49\u8f93\u5165\u8f93\u51fa\u6d41","text":"<p><code>BaseCmd</code>\u7c7b\u9ed8\u8ba4\u4f7f\u7528\u6807\u51c6\u8f93\u5165\u8f93\u51fa\uff0c\u4f46\u4e5f\u652f\u6301\u4e0e<code>cmd.Cmd</code>\u7c7b\u4f3c\u7684\u8f93\u5165\u8f93\u51fa\u6d41\u81ea\u5b9a\u4e49\u3002</p> <pre><code>out = io.StringIO()\ncmd = BaseCmd(sys.stdin, out)\ncmd.cmdloop()\nprint(out.getvalue())\n</code></pre>"},{"location":"zh/user_guide/core/#_8","title":"\u547d\u4ee4\u96c6","text":"<p>\u76ee\u524d<code>ptcmd</code>\u4e0d\u76f4\u63a5\u652f\u6301\u547d\u4ee4\u96c6\uff0c\u4f46\u53ef\u4ee5\u901a\u8fc7\u83f1\u5f62\u7ee7\u627f\u7684\u65b9\u5f0f\u5b9e\u73b0\u3002</p> <pre><code>import sys\nfrom ptcmd import Cmd\n\n\nclass App(Cmd):\n    \"\"\"\n    \u5b9a\u4e49\u5171\u6709\u7684\u5c5e\u6027\u53ca\u65b9\u6cd5\n    \"\"\"\n\n\nclass App1(App):\n    \"\"\"\n    \u5b9a\u4e49\u547d\u4ee4\u96c61\n    \"\"\"\n    def do_cmd1(self, argv: list[str]) -&gt; None:\n        ...\n\n\nclass App2(App):\n    \"\"\"\n    \u5b9a\u4e49\u547d\u4ee4\u96c62\n    \"\"\"\n    def do_cmd2(self, argv: list[str]) -&gt; None:\n        ...\n\n\nclass Cli(App1, App2):\n    \"\"\"\n    \u5229\u7528\u591a\u7ee7\u627f\u5408\u5e76\u547d\u4ee4\u96c6\n    \"\"\"\n\n\nif __name__ == '__main__':\n    sys.exit(Cli().cmdloop())\n</code></pre>"}]}